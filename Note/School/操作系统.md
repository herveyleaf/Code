# 第一章 引言

## 操作系统的概念

### 计算机系统的组成

- 硬件
    - CPU
    - 储存器：内存、外存
    - 输入设备：键盘、鼠标等
    - 输出设备：显示器、打印机、绘图仪
- 软件
    - 系统软件：操作系统；编译程序、DBMS等
    - 工具软件：软、硬件检测诊断程序
    - 应用软件

### 操作系统在计算机系统中的地位

紧贴系统硬件之上，所有其他软件之下（是其他软件的共同环境）

### 操作系统的作用

- 从资源管理的观点——OS作为资源管理器

    跟踪资源状态、分配资源、回收资源、保护资源

- 从软件分层、扩充机器的观点——虚拟机

    操作系统提供无限的内存、无限的CPU

    扩充机器，功能更强大、使用更方便

- 从服务用户的观点——OS用户与裸机间接口

    操作系统为方便用户使用计算机提供了二级访问接口：命令接口、调用接口、图形接口

    编程更为容易，软件可移植性强，使用更为方便

### 操作系统的定义

操作系统是**有效**控制和管理计算机系统的硬件和软件资源，**合理**的组织计算机工作流程，以**方便**用户使用的程序集合

- 有效：系统效率，资源利用率
- 合理：公平与否，如果不公平则会产生死锁或饥饿
- 方便：用户界面

## 操作系统的产生和发展

### 手工操作

工作特点：用户独占全机，CPU等待用户

### 单道批处理系统

利用磁带把若干个作业分类编成作业执行序列，每个批作业由一个专门的监督程序自动依次处理

批处理方式可分为联机批处理和脱机批处理

#### 联机批处理

用户提交作业、操作员合成批作业、批作业处理

但还是存在慢速的输入输出仍直接由主机来完成，输入输出时CPU处于等待状态的问题

#### 脱机批处理

利用卫星机完成输入输出功能，主机与卫星机可并行工作

优点是同一批内各作业的自动依次更替改善了主机CPU和IO设备的使用效率，提高了吞吐量；缺点是磁盘或磁带需要人工装卸，作业需要人工分类，监督程序易遭到用户程序的破坏

单道批处理的
- 特征：自动性、顺序性、单道性
- 缺点：一个用户独占全部资源，CPU负责计算也负责传输，CPU与外设速度不匹配；CPU与IO串行，资源利用率仍然很低

#### 中断技术和通道技术

- 中断

    指CPU在收到外部事件中断信号后，停止原来工作，转去处理该中断事件，完毕后回到原来断点继续工作  
    处理过程：中断请求、中断响应、中断点（暂停当前任务并保存现场），中断处理历程，中断返回

- 通道（又称IO处理机）

    实际上是一台功能单一、结构简单的IO处理机，直接控制外部设备，与内存进行数据传输

### 多道批处理系统

采用多道程序设计技术的批处理系统统称为多道批处理系统

#### 多道程序设计原理

在计算机内存中同时存放几道相互独立的程序，他们在管理程序的控制下相互穿插的运行，共享CPU和外设等资源

#### 多道程序设计的实现

- 存储保护与重定位：几道程序共享内存，必须提供必要的手段保护各道程序之间不互相侵犯
- 处理机管理和调度
- 资源的管理和调度

#### 多道程序设计的特征

- 多道：同时存在两道或以上的程序处于执行的开始点和结束点中间
- 宏观并行
- 微观串行

#### 多道批处理系统的优缺点

- 优点

    资源利用率高、作业吞吐量大

- 缺点

    用户交互性差、作业平均周转时间长

#### 多道批处理系统的核心技术

作业调度、资源共享、内存使用、内存保护、文件非顺序存放且随机存取

### 分时操作系统

分时：两个或两个以上的事件按时间划分轮流的使用计算机系统的某一资源

#### 分时系统实现方法

- 系统配置多路卡及时接受各终端输入命令和数据
- 及时处理，不允许某作业长期占用处理机

#### 分时系统的特点

同时性或多路性、独占性、及时性、交互性

#### 调进和调出

调进/调出是实现分时系统的一种主要方式，包括：

- 主存——后援存储器方式：内存只存放一个当前执行作业，其他放在外存上
- 多流调入调出方式：基于多道程序技术，主存中同时存在一个当前执行作业和多个后备作业

#### 分时系统的响应时间

响应时间为用户发出一条指令到系统处理完这条指令并做出回答所需要的时间，是衡量分时系统性能好坏的一个重要标志，但具体的响应时间与系统的用户个数及时间片大小有关；响应时间T=时间片q * 用户个数n,即T=nq

### 实时操作系统

实时操作系统主要用于过程控制、事务处理等有实时要求的领域，主要特征是实时性和可靠性

#### 实时系统的分类

- 实时控制：要求与被控制的变化速度相比，其反应速度足够快
- 实时信息处理系统：要求计算机能够在容许的延迟时间内响应外部的事件请求，完成对该事件的处理，并控制所有的实时设备和实时任务协调运行

#### 实时系统的特征

专用性、种类多、用途各异，一个基本特征是**事件驱动**

#### 与分时系统的比较

实时系统大多数是具有特殊用途的专用系统；实时系统的交互性很弱；实时系统的响应时间要求严格；两种系统均具备多路性、独立性、及时性、交互性、可靠性，而实时系统的及时性和可靠性要求更高

### 网络操作系统

在通常操作系统功能的基础上提供网络通信和网络服务功能的操作系统

### 分布式操作系统

以计算机网络为基础的计算机系统，包含多台处理机，每台处理机完成系统汇总指定的一部分功能，从硬件上讲，与计算机局域网没有任何区别

## 操作系统的特征

并发性、共享性、虚拟性、异步性

**并发和共享是现代操作系统的两个最基本特征**

### 并发性

并发：多个事件在同一时间间隔内发生  
并行：多个事件在同一时刻发生

单处理机系统中采用多道程序技术后，可以实现硬件之间的并行操作和程序之间的并发执行

### 共享性

指计算机系统中的各种软硬件资源都可以为多个用户同时使用

共享可分为互斥共享和同时共享

- 互斥共享

    也叫顺序共享，是指多个进程互斥地或排他性地使用某个资源

- 同时共享

    又叫并发共享， 是指在一段时间内，多个程序可以同时(宏观的)使用系统中的某个资源

### 虚拟性

通过某种技术，使物理上的一个实体映射为逻辑上的多个对应物

如Windows系统使用了虚拟存储技术，把外部存储器映射为用户自由使用的无限大的内存空间，即虚拟内存，这样保证了需要内存空间比世纪内存空间大的程序能正常运行

### 异步性

指内存中的多个进程都按照各自独立的、不可预知的速度向前推进。这是由于它们共享资源、并发执行

## 操作系统的功能

### 存储管理

目的是方便用户使用内存、提高内存的利用率、从逻辑上扩充内存

功能有：内存分配、地址映射、内存保护、内存扩充

### 进程管理

目的是对处理机的分配和运行实施有效管理，在多道程序环境下，处理机的分配和运行以进程为单位，因此对处理机的管理即对进程的管理

功能有：进程控制、进程同步、进程通信、进程调度

### 设备管理

目的是完成用户程序请求的IO操作，为用户程序分配IO设备、提高外部设备的利用率、尽可能的提高输入输出的速度、方便用户使用外部设备

功能有：设备分配、设备控制、设备无关性

### 文件管理

大量的信息以文件的形式放在外存，对信息的管理就是对文件的管理

功能有：文件存储空间的管理、目录管理、文件的读写管理、文件的存取控制

# 第二章 进程管理

## 进程的引入

### 程序的顺序执行

仅当前一操作（程序段）执行完后，才能执行后继

#### 程序顺序执行时的特征

- 顺序性：每一个操作必须在下一个操作开始之前结束
- 封闭性：程序在运行时独占系统全部资源，除初始状态之外，计算机内各资源的状态都是由程序决定的，只有程序本身的动作才能改变其环境，不受其他程序和外界因素的干扰
- 可再现性：只要程序执行时的环境和初始条件相同，重复执行程序的结果相同

### 程序的并发执行及其特征

- 间断性：程序在并发执行时，由于要共享资源，致使在并发程序之间形成了互相制约关系，导致并发程序具有“执行-暂停-执行”这种间断性的执行特征
- 失去封闭性：并发程序的执行必然受到其他程序的影响
- 不可再现性：由于失去了封闭性，也将失去可再现性

#### Bernstein条件

判断程序能否并发执行的条件

**两个进程的读集与写集的交集、写集和写集的交集为空集**

### 进程的概念

#### 进程的定义

1. 进程是程序的一次执行
2. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动
3. 进程是程序在一个数据集合上运行的过程，他是系统进行资源分配和调度的一个独立单位

#### 进程的特征

- 动态性：进程是一次执行过程，具有生命周期，由创建而产生，由调度而执行，由撤销而消亡
- 共享性：同一程序同时运行于不同数据集合时，构成不同的进程
- 独立性：进程是操作系统进行资源分配和保护的基本单位，也是系统调度的独立单位，凡是未建立进程的程序，都不能作为独立单位参与运行
- 并发性：各个进程是同时独立运行
- 异步性：进程以各自独立的、不可预知的速度向前推进
- 为了描述和记录进程的动态变化过程使其能够正确运行，还需要一个进程控制块

## 进程的状态及组成

### 进程的基本状态

#### 进程的三种基本状态及其转换

1. 运行状态：正在处理机上运行的状态
2. 就绪状态：已经获得了除处理机外的所有必要资源，只要获得处理机就可以运行的状态
3. 阻塞状态：当进程由于等待输入操作或某个同步时间而暂停运行时，就处于阻塞状态

运行态->就绪态：时间片已用完  
运行态->阻塞态：进程因某事件，如等待IO完成变成阻塞状态  
就绪态->运行态：进程调度程序把处理机分配给进程  
阻塞态->就绪态：某事件被接触，如IO完成

#### 创建状态和终止状态

- 创建状态：进程刚刚建立，但还未送入就绪态时的状态，新建态进程的程序保留在辅存中，通常是在磁盘中
- 终止状态：进程已经结束，释放了除进程控制块之外的所有资源，但尚未撤销时的状态

### 进程的挂起状态

挂起进程定义为暂时被淘汰出内存的进程，当条件允许时，会被操作系统再次调回内存，重新进入就绪态

#### 引入挂起状态的原因

终端用户的请求、父进程的请求、负荷调节的需要、操作系统的需要

### 进程控制块PCB

进程的组成：
- 进程控制块PCB
- 程序段
- 数据段
- 堆栈

#### PCB的作用和特点

- PCB是操作系统中最重要的数据结构，是进程存在的唯一标志
- PCB的作用是使一个在多道环境下不能独立运行的程序成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程
- PCB常驻内存，可以被操作系统中的多个模块读或修改
- PCB是进程实体的一部分，同进程一样具有一定的生命期， 且与进程保持一致

#### PCB中的信息

1. 进程标识符
2. 处理机状态
3. 进程调度信息
4. 进程控制信息

#### PCB的组织方式

1. 链接方式：使用队列的数据结构
2. 索引方式

## 进程控制

进程控制是进程管理中最基本的功能，主要包括创建新进程、撤销已完成的进程、将因发生异常情况而无法继续运行的进程处于阻塞状态、负责进程运行中的状态转换等功能

为了防止OS本身及关键数据遭受到应用程序的破坏，通常将处理机的执行状态分为**系统态**和**用户态**

- 系统态：又称管态，也称为内核态，具有较高的特权，能执行一切指令，访问所有的寄存器和存储区，传统的OS都在系统态运行
- 用户态：又称目态，具有较低特权的执行状态，仅能执行规定的指令，访问指定的寄存器和存储区

一般情况下，应用程序只能在用户态执行，不能去执行OS指令及访问OS区域，这样可以防止应用程序对OS的破坏

进程控制一般是由OS内核中的**原语**来实现的

原语是由若干条指令组成的，用于完成特定功能的一个特殊过程，它与一般过程的区别在于它们是原子操作

通常采用进程家族树来反映进程之间的创建与被创建的关系，子进程可以继承父进程所拥有的资源

#### 进程的创建与撤销

引起创建进程的事件：
- 由系统内核创建新进程
    - 用户登录
    - 作业调度
    - 提供服务
- 由应用程序创建新进程
    - 应用请求

进程的创建：

1. 申请空白PCB
2. 初始化进程控制块
3. 为新进程分配资源、分配存储空间
4. 如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列

进程的终止过程：

1. 从PCB集合中检索出该进程的PCB,读出相应状态
2. 终止该进程的执行，更改调度标志
3. 终止其所有子孙进程
4. 将其全部资源，归还给其父进程或系统


#### 进程的阻塞与唤醒

引起进程阻塞和唤醒的事件：

1. 请求系统服务
2. 启动某种操作
3. 新数据尚未到达
4. 无新工作可做

进程阻塞过程：

1. 停止进程的执行：进程通过调用阻塞原语block把自己阻塞，是一种主动行为
2. 把PCB中的现行状态改为阻塞，将PCB插入阻塞队列
3. 重新调度，将处理机分配给另一就绪程序

进程唤醒过程：

当被阻塞进程所期待的事件出现时，则由有关进程调用唤醒原语wakeup  
唤醒原语执行的过程：

1. 把该进程从阻塞队列中移出
2. 将该进程的PCB插入就绪队列
3. 将其PCB中的现行状态改为就绪

#### 进程的挂起与激活

1. 进程的挂起

    当出现了引起进程挂起的事件时，系统利用挂起原语suspend将指定进程或处于阻塞状态的进程挂起  
    挂起原语的执行过程：
    - 活动就绪->静止就绪（就绪->就绪挂起）
    - 活动阻塞->静止阻塞（阻塞->阻塞挂起）
    - 执行状态->重新调度（运行->就绪挂起）

2. 进程的激活过程

    系统将利用激活原语active将指定进程激活

    激活原语先将进程从外存调入内存，检查该进程的现行状态
    - 就绪挂起->就绪
    - 阻塞挂起->阻塞

## 线程

进程有两个基本属性
- 进程是拥有资源的独立单位
- 进程是独立调度和分派的基本单位

由于进程是资源拥有者，因而在进程的创建、撤销和切换中系统必须付出较大的时间、空间开销。因此，系统中所设置的进程数目不宜过多，进程切换的频率不宜过高，这就限制了进程并发程度的提高

### 线程的定义

线程是进程中的一个实体，是系统独立调度和分派的基本单位

### 进程与线程比较

- 调度：线程调度快，需要空间小，进程因拥有资源，调度时因负担过重而缓慢
- 并发性：不仅进程间可以并发执行，一个进程中的多个线程之间也可以并发执行
- 进程是资源的拥有者，线程不拥有资源，只有TCB及堆栈
- 系统开销：进程切换的开销远远大于线程切换的开销，线程的切换省去了资源的回收

# 第三章 进程同步与通信

## 进程的同步与互斥

### 同步与互斥的引入

OS引入进程后，由于进程并发执行所带来的异步性，可能会导致程序执行结果的不确定性，使程序执行时出现不可再现性，若资源分配不当，可能会出现死锁现象

进程互斥与同步的主要任务是使并发执行的诸进程之间能有效的共享资源和互相合作，从而使程序的执行具有可再现性

两种形式的制约关系（并发进程间的关系）
- 资源共享关系（间接相互制约）

    进程之间彼此无关，进程同步要确保诸进程互斥的访问临界资源
- 相互合作关系（直接相互制约）

    进程间存在先后次序关系，进程同步要确保诸进程在执行次序上的协调，时间上无差错

### 进程同步的基本概念

- 同步：多个进程中发生的事件存在着某种时序关系，它们必须按规定时序执行，以共同完成一项任务
- 互斥：多个进程不能同时使用同一资源
- 通信： 进程之间要传递一定的信息

### 临界资源与临界区

一段时间内只允许一个进程访问的资源称为临界资源，临界资源要求互斥的被访问

进程中访问临界资源的那段**程序**称为临界区

### 临界区应遵守的准则

- 空闲让进：当无进程处于临界区时，临界资源处于空闲状态，此时允许进程进入临界区
- 忙则等待：当已有进程进入临界区时，临界资源正在被访问，其他想进入临界区的进程必须等待
- 有限等待：对于要求访问临界资源的进程，应保证在有限的时间内进入，以免进入死等状态
- 让权等待：当进程不能进入临界区时，应立即释放处理机，以免进程进入忙等

### 互斥实现的硬件方法

- 禁止中断
- 专用机器指令
    - TS指令
    - swap指令

#### TS指令

设布尔变量lock，初值为false，表示资源空闲，当lock=true时，表示资源正在被使用，利用TS指令实现互斥

缺点是没有做到让权等待

### 互斥实现的软件方法

- 单标志算法
- 双标志、先检查算法
- 双标志、先修改后检查算法
- 先修改、后检查、后修改算法

### 信号量和PV操作

通过两个标准的原子操作：wait(S)和signal(S)来访问，这两个操作一般被分别成为P、V操作

#### 信号量的物理意义

从资源的观点看信号量的意义：

P操作：实现资源的分配  
V操作：实现资源的回收

s.value的初值表示系统中某种资源数目  
P(s)表示要申请一个资源  
V(s)表示要释放一个资源  
s.value<0时，|s.value|表示等待队列的进程数

#### 信号量用法

为使多个进程能互斥访问某临界资源，只需为该资源设置**互斥信号量mutex**，并设mutex的初值为1；然后将各进程的临界区置于wait(mutex)和signal(mutex)操作之间

## AND信号量

AND信号量的基本思想是：
1. 将进程所有资源，一次性的全部分配给进程或者回收
2. 采取原子操作方式：要么全部分配到进程，要么一个也不分配
3. 在wait操作中，增加了一个AND条件，故称为AND同步，或称为同时wait操作

# 第四章 调度与死锁

## 处理机调度的基本概念

### 高级、中级和低级调度

#### 高级调度

也称作业调度，在每次执行作业调度时，都需做出两个决定：接纳多少个作业、接纳哪些作业

#### 中级调度

也称内存调度、对换程序

主要作用是：内存和外存对换区之间进行进程对换，以解决内存紧张问题

#### 低级调度

也称进程调度、微观调度

目的是解决就绪队列中的哪些进程将获得处理机

### 进程调度方式

- 不可剥夺方式

    也称非抢占方式，采用这种调度方式时，一旦把处理机分配给某个进程，该进程将一直执行下去，直到运行完毕或因某种原因不能运行，才把处理机分配给其它进程，绝不允许其它进程强占正在运行进程占有的处理机

- 可剥夺方式

    也称为抢占方式，在这种方式下，允许一个进程按照某种原则，抢占其它进程占有的处理机

### 进程调度时机

- 进程退出
- 进程阻塞
- 新进程创建
- 中断发生
- 时钟中断

### 调度的性能准则

- 面向用户的准则
    - 响应时间快（响应时间是从用户通过键盘提交请求到首次得到响应的时间）
    - 周转时间短（周转时间是作业从提交到完成的时间间隔）
    - 优先权准则
    - 截止时间的保证
- 面向系统的准则
    - 系统吞吐量（单位时间内完成的作业数）
    - 处理机利用率
    - 各类资源平衡利用
    - 公平

#### 周转时间定义

周转时间Ti=t(finish)-t(submit)  
平均周转时间T=∑Ti/n
带权周转时间Wi=周转时间/实际服务时间=(等待时间+实际服务时间)/实际服务时间

## 调度算法

### 先来先服务(FCFS)

对于作业调度，从后备作业中选择最先进入该队列的作业然后调入内存，为他们分配资源、创建进程然后放入就绪队列  
对于进程调度，从就绪队列中选择最先进入该队列的进程，分配处理机

特点是有利于长作业，短作业不满

### 短作业优先(SJF)

短作业优先是从后备队列中选择估计运行时间最短的作业，将他们调入内存；短进程优先是从就绪队列中选择估计运行时间最短的进程，将处理机分配给它

特点是极端情况下长作业得不到调度，完全不考虑紧迫程度，使紧急事件得不到处理

### 时间片轮转算法(Round Robin)

本算法主要用于微观调度，设计目标使提高资源利用率

基本思路是通过时间片轮转，提高进程并发性和响应时间特性，从而提高资源利用率

#### Round Robin算法

- 将系统中所有的就绪进程按照FCFS原则排成一个队列
- 每次调度时将CPU分派给队首进程，让其执行一个时间片
- 在一个时间片结束时，发生时钟中断
- 调度程序暂停当前进程的执行，将其送到就绪队列的末尾，通过上下文i求耳环执行当前队首进程
- 进程可以未使用完一个时间片就出让CPU

#### 时间片长度的确定

- 过长：退化为FCFS算法，进程在一个时间片内都执行完，响应时间长
- 过短：用户的一次请求需要多个时间片才能处理完，上下文切换次数增加，响应时间长
- 影响因素：系统的处理能力、负载情况、对响应时间的要求

响应时间T=用户数目N*时间片q

### 优先权调度算法

从后备队列中选择若干优先权最高的作业，将他们调入内存，或从就绪队列中选择优先权最高的进程，将处理机分配给它

优先权类型：
- 静态优先权：确定因素有进程类型、进程对资源的需求、用户要求
- 动态优先权：确定因素有等待时间、运行时间

#### 非抢占式优先权算法

系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去直至完成，或因发生某事件使该进程放弃处理机

主要用于批处理系统中，也用于某些对实时性要求不高的实时系统中

#### 抢占式优先权调度算法

系统把处理机分配给优先权最高的进程，但在其执行期间，只要出现了另一个优先权更高的进程，进程调度程序就立即停止当前进程的执行，重新将处理机分配给新到的优先权最高的进程

这种算法能更好的满足紧迫作业的要求，常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中

### 多级反馈队列调度算法

根据作业的性质和类型不同，将就绪队列再分为若干个子队列，每个进程分属一个队列

在多级队列的基础上，不但设多个队列，且为每个队列赋予不同的优先权，第一个队列优先权最高，第二个队列次之，依次降低

各个队列中的进程执行时间片大小逐渐增大

新进程投入第一个队列

调度从第一个队列进行，仅当第一个队列为空时，才调度第二个队列中的进程

## 死锁的基本概念

### 产生原因
- 资源数<请求该类资源的进程数
- 进程的推进顺序非法

### 产生死锁的四个必要条件

- 互斥条件
- 请求保持条件
- 不剥夺条件
- 环路条件

### 处理死锁的基本方法

- 静态策略：预防死锁，进程创建时就分配所有需要的资源
- 动态策略：避免死锁，执行时动态改变资源分配策略
- 鸵鸟策略：置之不理

## 死锁的预防与避免

### 死锁的预防

死锁的预防措施低效

#### 预先静态分配

系统要求所有进程一次性的申请所需的资源

#### 资源的有序分配

令所有资源排队，并赋予不同的序号，进程请求资源时必须严格按照递增的次序提出，消除环路

### 死锁的避免

避免死锁的关键就是，让系统在动态分配资源的过程中，不要进入不安全状态

#### 安全状态与不安全状态

安全状态是指系统至少存在一个安全序列，按照这个序列为进程分配资源，直到满足最大需求，每个进程都可顺序完成，若系统不存在一个这样的安全序列，则系统处于不安全状态

#### 银行家算法

- 进行资源预分配
- 实施安全检测
    - 安全：真正资源分配
    - 不安全：回到预分配前状态

Resource为系统中每种资源的总量  
Available为没有分配的每种资源总量  
Need为每个进程对每种资源的需求  
Allocation为当前分配情况

1. 如果Request<=Need，则转向2，否则认为出错
2. 如果Request<=Available，则转向3，否则表示尚无足够资源，需等待
3. 系统试探着把资源分配给进程，并修改如下数值  
    Available=Available-Request  
    Allocation=Allocation+request
4. 系统执行安全性算法，检查此次资源分配后系统是否处于安全状态，若安全才正式将资源分配给进程，否则恢复原来的资源分配状态，让进程等待

## 死锁的检测与解除

### 死锁的检测

当且仅当资源分配图时不可完全简化的时，为死锁状态

### 死锁的解除

常用的两种方法是：剥夺资源、撤销进程