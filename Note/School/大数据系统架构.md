# 第一章 大数据概述

## 大数据时代

三次信息化浪潮，每隔15年迎来一次重大变革，第一次在1980年前后

信息科技为大数据时代提供技术支撑
- 存储设备容量不断增加
- CPU处理能力大幅提升
- 网络带宽不断增加

大数据发展的三个阶段
1. 萌芽期：1990到2000，数据挖掘理论和数据库技术的成熟
2. 成熟期：2000到2010，Web2.0发展迅猛，非结构化数据大量产生，Hadoop平台大行其道
3. 大规模应用期：2010后

## 大数据概念

大数据具有数据量大、数据类型繁多、处理速度快、价值密度低等特点，统称为4V

大数据不仅是数据的大量化，而是包含快速化、多样化和价值化

大数据摩尔定律：数据每年以50%的速度增长

大数据是由10%的结构化和90%的非结构化数据组成
- 结构化数据：可以用固定模式进行描述的数据
- 非结构化数据：包括所有格式的文档、文本、图片、图像和音视频信息

人类先后经历了实验、理论、计算和数据四种范式

大数据颠覆了传统的思维方式：
- 全样而非抽样
- 效率而非精确
- 相关而非因果

## 大数据关键技术

两大核心技术：分布式存储、分布式处理

大数据技术主要包括：数据采集、数据存储和管理、数据处理与分析、数据安全和隐私保护几个层面的内容

## 大数据计算模式

- 批处理计算：针对大规模数据的批量处理，代表产品有MapReduce和Spark等
- 流计算：针对流数据的实时计算
- 图计算：针对大规模图结构数据的处理
- 查询分析计算：大规模数据的存储管理和查询分析

大数据架构：主要思想是将数据处理流程分解成三层，批处理层、流式处理层和服务层

## 大数据的应用

1. 互联网领域
2. 电信领域
3. 医疗领域
4. 金融领域

大数据与机器学习两者是互相促进，相依相存的关系，大数据的核心是利用数据的价值，机器学习是利用数据价值的关键技术。大数据不等同于机器学习

大数据产业包括IT基础设施层、数据源层、数据管理层、数据分析层、数据平台层和数据应用层

## 大数据、云计算、物联网

云计算为大数据提供了技术基础，大数据为云计算提供用武之地；物联网是大数据的重要来源，大数据技术为物联网数据分析提供支撑；云计算为物联网提供海量数据存储能力，物联网为云计算提供了广阔的应用空间

### 云计算

分为三层：
- SaaS：应用层 软件即服务
- PaaS：平台层 平台即服务
- IaaS：基础设施层 基础设施即服务

关键技术：虚拟化、分布式存储、分布式计算、多租户等

### 物联网

关键技术：识别和感知技术、网络与通信技术、数据挖掘和融合技术等

# 大数据处理架构Hadoop

Hadoop是基于Java语言开发的，具有很好的跨平台性，可以部署在廉价的计算机集群中。核心是分布式文件系统HDFS和MapReduce

Hadoop具有以下几个特性：
- 高可靠性
- 高效性
- 高可扩展性
- 高容错性
- 成本低
- 运行在Linux平台
- 支持多种编程语言

Hadoop包括三种安装方式：
- 单机模式：只在一台机器上运行，采用本地文件系统存储，没有分布式文件系统
- 伪分布式模式：采用分布式文件系统HDFS存储，但是HDFS的名称节点和数据节点都在同一台机器上
- 分布式模式：采用分布式文件系统HDFS存储，而且HDFS的名称节点和数据节点位于不同机器上

# 分布式文件系统HDFS

## 文件系统

文件系统是指含有大量的文件及其属性说明、对文件进行操作和管理的软件，以及向用户提供的使用文件的接口的集合
- 操作——有关文件操作过程
- 实体——文件本身
- 接口——用户使用文件的接口：编程接口、命令接口

文件级别的分布式文件系统架构难以负载均衡且难以并行处理，所以使用块级别的分布式文件系统架构

## 分布式文件系统

分布式文件系统是一种通过网络实现文件在多台主机上进行分布式存储的文件系统，分布式文件系统的设计一般采用客户机/服务器模式

### 分布式文件系统的结构

分布式文件系统在物理结构上是由计算机集群中的多个节点构成的，这些节点分为两类，一类叫**主节点**或者**名称节点**，另一类叫做**从节点**或者**数据节点**

## HDFS简介

HDFS要实现以下目标：
- 兼容廉价的硬件设备
- 流数据读写
- 大数据集
- 简单的文件模型
- 强大的跨平台兼容性

HDFS特殊的设计在实现上述特性同时，也使得自身具有一些局限性：
- 不适合低延迟数据访问
- 无法高效存储大量小文件
- 不支持多用户写入及任意修改文件

### 块

HDFS默认一个块64MB，一个文件被分为多个块，以块作为存储单位，块的大小远远大于普通文件系统，可以最小化寻址开销

HDFS采用块的概念可以带来以下几个好处：
- 支持大规模文件存储
- 简化系统设计
- 适合数据备份

### 名称节点和数据节点

#### NameNode

- 存储元数据
- 元数据保存在内存中
- 保存文件、block、datanode之间的映射关系

元数据存储机制：
- 内存中有一份完整的元数据(metadata)
- 磁盘由一个元数据镜像(fsimage)文件
- 用于衔接内存metadata和持久化元数据镜像fsimage之间的操作日志(edits文件)

当客户端对HDFS中的文件进行新增或者修改操作，操作记录首先被记入edits日志文件中，当客户端操作成功后，相应的元数据会更新到内存metadata中元数据的checkpoint

每隔一段时间，会由secondary namenode将namenode上积累的所有edits和一个最新的fsimage下载到本地，并加载到内存进行merge，这个过程称为checkpoint

##### 名称节点的数据结构：

在HDFS中，名称节点负责管理分布式文件系统的命名空间(namespace)，保存了两个核心的数据结构，fslmage和editlog
- FsImage文件用于维护文件系统树以及文件树中所有的文件和文件夹的元数据
- 操作日志文件editlog中记录了所有针对文件的创建、删除、重命名等操作

名称节点记录了每个文件中各个块所在的数据节点的位置信息

##### FsImage文件

FsImage文件包含文件系统中所有目录和文件inode的序列化形式。每个inode是一个文件或目录的元数据的内部表示。FsImage文件没有记录每个块存储在哪个数据节点，而是由名称节点把这些映射信息保留在内存中，当数据节点加入HDFS集群时，数据节点会把自己所包含的块列表告知给名称节点，之后会定期执行这种操作

##### 名称节点的启动

在名称节点启动的时候，它会将FsImage文件中的内容加载到内存中，之后再执行editlog文件中的各项操作，使得内存中的元数据和实际的同步

一旦在内存中成功建立文件系统元数据的映射，则创建一个新的FsImage文件和一个空的editlog文件

在名称节点运行期间，HDFS的所有更新操作都是直接写到editlog里，editlog文件将会变得很大，这对名称节点运行时候没有什么明显影响，但是当名称节点重启的时候，名称节点需要将FsImage里的所有内容加载到内存中然后再一条条的执行editlog文件中的记录，使名称节点启动操作非常慢，解决方案使使用SecondaryNameNode第二名称节点，第二名称节点一般单独运行在一台机器上

##### 第二名称节点

定期和Namenode通信，请求其停止使用Editlog文件，暂时将新的写操作写到一个新的文件edit.new上，这个操作是瞬间完成的。SecondaryNamenode通过HTTP get的方式从namenode获取FsImage和Editlog文件。下载下来的FsImage载入到内存，然后一条条的执行EditLog文件中的更新操作，使FsImage保持最新，这个操作就是EditLog和FsImage的合并。然后将新的FsImage发送到NameNode节点上，替换旧的FsImage文件，同时用edit.new替换EditLog文件

#### DataNode

数据节点是HDFS的工作节点，负责数据的存储和读取，会根据客户端或者是名称节点的调度来进行数据的存储和检索，并且向名称节点定期发送自己所存储的块的列表

每个数据节点中的数据会被保存在各自节点的本地Linux文件系统中

## HDFS体系结构

HDFS采用了主从结构模型，一个HDFS集群包括一个名称节点和若干个数据节点。名称节点作为中心服务器，负责管理文件系统的命名空间和客户端对文件的访问。集群中的数据节点一般是一个节点运行一个数据节点进程，负责处理文件系统客户端的读写请求，在名称节点的统一调度下进行数据块的创建、删除和复制等操作

名称节点不参与数据传输，一个文件的数据可以被并发访问，提高了数据访问速度

### 通信协议

- 所有的HDFS通信协议都是建立在TCP/IP协议基础之上的
- 客户端通过一个可配置的端口向名称节点主动发起TCP链接，并使用客户端协议与名称节点进行交互
- 名称节点和数据节点之间则使用数据节点协议进行交互
- 客户端与数据节点的交互通过RPC来实现，在设计上名称节点不会主动发起RPC，而是响应来自客户端和数据节点的RPC请求

### 客户端

HDFS客户端是一个库，暴露了HDFS文件系统接口，严格来说客户端并不是HDFS的一部分

### HDFS体系结构的局限性和优缺点

#### 局限性

1. 命名空间的限制：HDFS中的文件、块与存储位置信息是保存在名称节点的内存中的，因此名称节点能够容纳的对象的个数会受到内存空间大小的限制
2. 性能的瓶颈：真个分布式文件系统的吞吐量受限于单个名称节点的吞吐量
3. 隔离问题：由于集群中只有一个名称节点，只有一个命名空间，因此无法对不同应用程序进行隔离
4. 集群的可用性：一旦这个唯一的名称节点发生故障，会导致整个集群变得不可用

#### 优点

1. 高容错性：数据自动保存多个副本，某一个副本丢失后它可以自动恢复
2. 适合大数据处理：数据规模能够达到TB甚至PB级别，能够处理百万规模以上的文件数量
3. 可构建在廉价机器上，通过多副本机制提高可靠性

#### 缺点

1. 不适合低延时数据访问，比如毫秒级的存储数据
2. 无法高效的对大量小文件进行存储
3. 不支持并发写入和文件随机修改

## HDFS存储原理

### 冗余数据保存

HDFS采用多副本方式对数据进行冗余存储，通常一个数据块的多个副本会被分布到不同的数据节点上，这种多副本方式具有以下几个优点：
1. 加快数据传输速度
2. 容易检查数据错误
3. 保证数据可靠性

### RAID

RAID即独立磁盘冗余阵列，简称为磁盘阵列，用多个独立的磁盘组成在一起形成一个大的磁盘系统，从而实现比单块磁盘更好的存储性能和更高的可靠性

#### RAID0

RAID0将多块磁盘组合在一起形成一个大容量的存储，当我们要写数据的时候会将数据分为N份，以独立的方式实现N块磁盘的读写，那么这N份数据会同时并发的写到磁盘中，因此执行性能非常高

#### RAID1

RAID1在往磁盘写数据的时候，将同一份数据无差别的写两份到磁盘，分别写到工作磁盘和镜像磁盘，两块磁盘当一块用，成本较高

#### RAID10

基于RAID1模式将磁盘分为两份，且在每一份磁盘上又会基于RAID0技术将数据分为N份并发的读写

### 数据存取策略

#### 数据存放

- 第一个副本：放置在上传文件的数据节点，如果是集群外提交，则在集群内随机挑选一台磁盘不太满、CPU不太忙的节点
- 第二个副本：放置在与第一个副本不同的机架的节点上
- 第三个副本：与第一个副本相同机架的其他节点上
- 更多副本：随机节点

#### 数据读取

HDFS提供了一个API可以确定一个数据节点所属的机架ID，客户端也可以调用API获取自己所属的机架ID

客户端读取数据时，从名称节点获得数据块不同副本的存放位置列表，列表中包含了副本所在的数据节点，可以调用API来确定客户端和这些数据节点所属的机架ID，当发现某个数据块副本对应的机架ID和客户端对应的机架ID相同时就优先选择该副本读取数据，如果没有发现就随机选择一个副本读取数据

### 数据错误与恢复

HDFS把硬件出错看作一种常态而不是异常，并设计了相应的机制检测数据错误和进行自动恢复，主要包括以下几种情形：名称节点出错、数据节点出错和数据出错

#### 名称节点出错

通过SecondaryNameNode中的fslmage和editlog数据进行恢复

#### 数据节点出错

每个数据节点会定期向名称节点报告自己的状态，当数据节点发生故障或者网络断网时，名称节点就无法收到来自数据节点的心跳信息，这些数据节点就会被标记为宕机，节点上面的所有数据都会被标记为不可读，名称节点不会再给它们发送任何IO请求

这时，有可能由于有写数据节点的不可用，导致一些数据块的副本数量小于冗余因子。名称节点会定期检查这种情况，一旦发现某个数据块的副本数量小于冗余因子，就会启动数据冗余复制，为它生成新的副本

#### 数据出错

网络传输和磁盘错误等因素都会造成数据错误

客户端在读取到数据后会采用md5和sha1对数据块进行校验以确定数据的正确，在文件被创建时，客户端会对每一个文件块进行信息摘录，并把这些信息写入到同一个路径的隐藏文件中，当客户端读取文件时，会先读取该信息文件，然后利用该信息文件对每个读取的数据块进行校验，如果校验出错，客户端就会请求到另一个数据节点读取该文件块，并且向名称节点报告这个文件块有错误，名称节点会定期检查并重新复制这个块

# 分布式数据库HBase

## 概述

Hadoop可以很好地解决大规模数据的离线批量处理问题，但是受限于Hadoop MapReduce编程框架的高延迟数据处理机制，Hadoop无法满足大规模数据实时处理的需求

HDFS面向批量访问模式，不是随机访问模式

### 与传统关系数据库的对比

- 关机数据库采用关系模型，HBase采用更加简单的数据模型，把数据存储为未经解释的字符串
- 关系数据库包含丰富的操作，涉及复杂的多表连接，HBase操作不存在复杂的表与表之间的关系
- 关系数据库是基于行模式存储的，HBase基于列存储
- 关系数据库可以构建多个索引，HBase只有行键一个索引
- 关系数据库的更新操作会替换原来的旧值，HBase会生成一个新的版本
- 关系数据库很难横向扩展，HBase可以实现灵活的扩展

## HBase数据模型

HBase是一个稀疏、多维度、排序的映射表，这张表的索引是行键、列族、列限定符和时间戳

每个值都是一个未经解释的字符串，没有数据类型

表中的数据，每一行都有一个可排序的行键和任意多的列，表在水平方向由一个或多个列族组成，一个列族可以包含任意多个列，同一个列族里的数据存储在一起

通过行、列族和列限定符确定一个单元格，一个单元格内保存同一份数据的多个版本，用时间戳进行索引

## HBase的实现原理

### HBase功能组件

HBase的实现包括三个主要的功能组件
- 库函数：链接到每个客户端
- 一个Master主服务器
- 多个Region服务器
- zookeeper

主服务器负责管理和维护HBase表的分区信息，维护Region服务器列表，分配Region，负载均衡

Region服务器负责存储和维护分配给自己的Region，处理来自客户端的读写请求

客户端并不直接从Master主服务器上读取数据，而是在获得Region的存储位置信息后，直接从Region服务器上读取数据，客户端并不依赖Master，而是通过zookeeper来获得Region位置信息，大多数客户端从不和Master通信，使得Master负载很小

zookeeper保证任何时候，集群中只有一个Master，存储Region的寻址入口，实时监控Region服务器并通知Master

### 表和Region

开始只有一个Region，后来不断分裂。Region拆分的操作非常快，因为拆分后的Region读取的仍然是原存储文件，直到合并过程把存储文件异步地写到独立的文件之后，才会读取新文件

每个Region默认大小是100MB到200MB，目前建议1GB到2GB。同一个Region不会被分拆到多个Region服务器，每个Region服务器存储10到1000个Region

### Region的定位

元数据表，又叫.META.表，存储了Region和Region服务器的映射关系，当HBase表很大时，.META.表也会被分裂成多个Region

根数据表，又名-ROOT-表，记录所有元数据的具体位置，-ROOT-表只有唯一一个Region，名字是在程序中被写死的

Zookeeper文件记录了-ROOT-表的位置

#### HBase的三层结构

1. Zookeeper文件：记录了-ROOT-表的位置信息
2. -ROOT-表：记录了.META.表的Region位置信息，-ROOT-表只能有一个Region，通过-ROOT-表就能访问.META.表中的数据
3. .META.表：记录了用户数据表的Region位置信息，.META.表可以有多个Region，保存了HBase中所有用户数据表的Region位置信息

客户端访问数据时会进行三级寻址，为了加速寻址，客户端会缓存位置信息，寻址过程客户端只需要访问zookeeper服务器，不需要连接Master服务器

为了加快访问速度，.META.表的全部Region会被保存在内存中

## HBase运行机制

### HBase系统架构

#### 客户端

客户端包含访问HBase的接口，同时在缓存中维护着已经访问过的Region位置信息，用来加快后续数据访问过程

#### Zookeeper服务器

可以帮助选举一个Master作为集群的总管，保证在任何时刻总有唯一的Master在运行，避免了Master的单点失效问题

#### Master服务器

主要负责表和Region的管理工作
- 管理用户对表的增删改查
- 实现不Region服务器之间的负载均衡
- 在Region分裂或合并后重新调整Region的分布
- 对发生故障失效的Region服务器上的Region进行迁移

#### Region服务器

负责维护分配给自己的Region，并响应用户的读写请求

### Region服务器工作原理

#### 用户读写数据

用户写入数据时，被分配到相应的Region服务器去执行，用户数据首先被写入到MemStore和HLog中，只有当操作写入HLog之后，commit()调用才会将其返回给客户端，当用户读取数据时，Region服务器首先访问MemStore缓存，如果找不到，再去磁盘上的StoreFIle中寻找

##### 写数据

Region服务器收到写请求后，将写入的数据以追加的方式写入HDFS的日志文件，该日志被称为WAL，主要作用时当Region服务器突然宕机后重新恢复丢失的数据

Region服务器将数据写入内存数据结构MemStore中，之后通知客户端数据写入成功，当MemStore所占内存达到阈值后，Region服务器会将数据顺序刷新HDFS中保存成HFile格式的文件

##### 读数据

扫描器查找读缓存BlockCache，它内部缓存了最近读取过的数据，再查找写缓存MemStore，它内部缓存了最近写入的数据，如果仍未找到目标数据，则读取StoreFile中的数据

#### 缓存的刷新

系统会周期性地把MemStore缓存里的内容刷写到磁盘的StoreFile文件中，清空缓存，并在HLog中写入一个标记

每次刷写都生成一个新的StoreFile文件，因此，每个Store中包含多个StoreFile文件

每个Region服务器都有一个自己的HLog文件，每次启动都检查该文件，确定最近一次执行缓存刷新操作之后是否发生新的写入操作，如果发现更新，则先写入MemStore，再刷写到StoreFile，最后删除旧的Hlog文件

#### StoreFile的合并

每次刷写都生成一个新的StoreFile，数量太多影响查找速度，调用Store.compact()把多个合并成一个，合并操作比较耗费资源，只有数量达到一个阈值才启动合并

### Store工作原理

Store是Region服务器的核心，多个StoreFile合并成一个Store File，单个StoreFile过大时，又触发分裂操作，1个父Region被分裂成两个子Region

### HLog工作原理

HBase采用HLog保证系统恢复，为每个Region服务器配置了一个HLog文件，是一种WAL，用户更新数据必须先写入日志后，才能写入MemStore缓存，并且直到MemStore缓存内容对应的日志已经写入磁盘，该缓存内容才能被刷写到磁盘

Zookeeper会实时监测每个Region服务器的状态，当某个Region服务器发生故障，Zookeeper会通知Master，Master会首先处理该故障Region服务器上的HLog文件，这个遗留的HLog文件包含了来自多个Region对象的日志记录。系统会根据每条日志记录所属的Region对象对HLog数据进行拆分，分别放到相应Region对象的目录下，然后再将失效的Region重新分配到可用的Region服务器上，并把与该Region对象相关的HLog日志记录也发送给相应的Region服务器

Region服务器领取到分配给自己的Region对象以及相应的HLog日志后，会重新做一遍日志记录中的各种操作，把日志记录中的数据写入到MemStore缓存中，然后刷写到磁盘的StoreFile中

Region服务器中多个Region共用一个HLog日志的优点是提高对表的写操作性能，缺点是恢复时需要分拆日志

# NoSQL数据库

## 简介

NoSQL指的是Not only SQL

通常，NoSQL具有以下几个特点：
- 灵活的可扩展性
- 灵活的数据模型
- 与云计算紧密融合

## NoSQL兴起的原因

1. 关系数据库已经无法满足Web2.0的需求
2. 同一套模式很难适用于截然不同的业务场景
3. 关系数据库的特性不再被需要

## NoSQL和关系数据库的比较

### 关系数据库

- 优势：以完善的关系代数理论作为基础，有严格的标准，支持ACID四性，借助索引机制可以实现高效查询，技术成熟
- 劣势：可扩展性差，无法较好支持海量数据存储，数据模型过于死板

### NoSQL数据库

- 优势：支持超大规模数据存储，具有强大的扩展能力
- 劣势：缺乏数学理论基础，复杂查询性能不高，技术不成熟，缺乏技术支持

## NoSQL的四大类型

典型的NoSQL数据库通常包括键值数据库、列族数据库、文档数据库和图数据库

### 键值数据库

数据存储为键值对，键是一个字符串对象，值可以是任意类型的数据

### 列族数据库

数据模型为列族，分布式的存储数据

### 文档数据库

数据模型是键值对，值是版本化的文档

### 图数据库

数据模型为图结构，复杂度较高

## NoSQL的三大基石

### CAP

- C：一致性，指任何一个读操作总能读到之前完成的写操作的结果，即所有节点再同一时间具有相同的数据
- A：可用性，指可以再确定的时间内返回操作结果，不管成功与否都有响应
- P：分区容忍性：指当出现网络分区(即系统中一部分节点无法和其他节点通信)时，分离的系统也能够正常运行

一个分布式系统不能同时满足CAP三种特性

### BASE

BASE的基本含义是：基本可用、软状态和最终一致性

- 基本可用

    指一个分布式系统的一部分发生问题变得不可用时，其他部分仍然可以正常使用，即允许分区失败的情形出现

- 软状态

    与硬状态相对应，数据库保存的数据是硬状态时，可以保证数据一致性，即数据一直是正确的，软状态指状态可以有一段时间不同步，具有一定的滞后性

- 最终一致性

    一致性包括强一致性和弱一致性，最终一致性是弱一致性的一种特例，允许后续的访问操作可以暂时读不到更新后的数据，但经过一段时间后，必须最终读到更新后的数据

#### ACID

- A：原子性，指事务必须是原子工作单元，要么全部执行，要么全都不执行
- C：一致性：指事务在完成时，必须使所有的数据都保持一致状态
- I：隔离性：指由并发事务所做的修改必须与任何其它并发事务所作的修改隔离
- D：持久性：指事务完成之后对于系统的影响是永久性的

### 最终一致性

对于分布式数据系统
- N指数据复制的份数
- W指更新数据时需要保证写完成的节点数
- R指读取数据时需要读取的节点数

若W+R>N，写的节点和读的节点重叠，则是强一致性；若W+R<=N，则是弱一致性，一般设置N>=3

# MapReduce

## 概述

MapReduce相较成熟的并行计算框架有以下的优点：
- 非共享式，容错性好
- 使用普通PC机，价格便宜扩展性好
- 学习简单
- 适用于批处理、非实时以及数据密集型计算

MapReduce将并行计算过程高度抽象到两个函数：Map和Reduce

一个MapReduce模型中只能包含一个Map阶段和一个Reduce阶段，或者只有Map阶段，如果业务逻辑非常复杂，只能多个MapReduce程序串行运行

## MapReduce的体系结构

### MapReduce1.0

主要由四个部分组成，分别是Client、JobTracker、TaskTracker以及Task

- Client

    用户编写的MapReduce程序通过Client提交到JobTracker端，用户可以通过Client提供的一些接口来查看作业运行状态

- JobTracker

    负责监控资源和作业调度

- TaskTracker

    周期性的通过心跳将本节点上资源的使用情况和任务的运行进度汇报给JobTracker，同时接收JobTracker发来的命令

- Task

    分为MapTask和ReduceTask两种，均由TaskTracker启动

### MapReduce2.6

主要由ResourceManager、NodeManager、MRApplicationMaster和Container组成

### MapReduce的设计目标

1. 易于编程：不考虑数据分片、数据传输、节点间通信等
2. 良好的扩展性：数据量增大时，可以线性扩展集群能力
3. 高容错性：通过计算迁移、数据迁移等策略提高容错性和可用性
4. 高吞吐率：在高吞吐率和低延迟之间权衡

## MapReduce工作流程

主要分为输入、Map、Shuffle、Reduce和输出五个阶段

不同的Map任务之间不会进行通信，不同的Reduce任务之间也不会发生任何信息交换，用户不能显式的从一台机器向另一台机器发送消息，所有的数据交换都是通过MapReduce框架自身取实现的

HDFS以固定大小的block为基本单位存储数据，队MapReduce而言，处理单位是split，这是一个逻辑概念，划分方法由用户自己决定

Hadoop为每个split创建一个Map任务，split的多少决定了Map任务的数目，大多数情况下，理想的分片大小是一个HDFS块

最优的Reduce任务个数取决于集群中可用的Reduce任务槽slot的数目，通常设置比slot稍微小一些的Reduce任务个数，这样可以预留一些系统资源处理可能的错误

### Map详细流程

Map任务分为五个阶段

- Read阶段：通过InputFormat，从split中解析出一系列的键值对
- Map阶段：将解析出的键值对依次交给用户编写的map()函数处理，并产生一系列新的键值对
- Collect阶段：在map()函数中，当数据处理完成后，一般会调用函数输出结果，这个函数将键值对划分成若干个数据分片，并写入环形内存缓冲区
- Spill阶段：溢写，写入磁盘前，进行本地排序
- 归并阶段：将临时文件合并为一个文件

### Reduce详细流程

Reduce任务分为五个阶段

- Shuffle阶段：从各个Map任务上拷贝数据分片，可能需要写到磁盘
- Merge阶段：对所拷贝的数据进行合并
- Sort阶段：归并排序
- Reduce阶段：执行Reduce()函数
- Write阶段：将输出结果写到HDFS

### Shuffle过程详解

#### Map端的Shuffle

每个Map任务分配一个缓存，默认为100MB，设置溢写比例为0.8，分区默认采用哈希函数，排序是默认的操作，排序后可以合并，合并不能改变最终结果，在Map任务全部结束前进行归并，归并得到一个大的文件放在本地磁盘，文件归并时如果溢写文件数量大于预定值，默认是3，则可以再次启动Combiner

归并和合并的区别：两个键值对<"a", 1>和<"a", 1>，如果合并会得到<"a", 2>，如果归并会得到<"a", <1, 1>>

#### Reduce端的Shuffle

Reduce任务通过RPC向JobTracker询问Map任务是否已经完成，若完成，则领取数据；Reduce领取数据先放入缓存，来自不同Map机器，先归并，再合并后写入磁盘；多个溢写文件归并成一个或多个大文件，文件中的键值对是排序的；当数据很少时不需要溢写到磁盘，直接再缓存中归并然后输出给Reduce