# 进程与线程

## 进程

在任何多道程序设计系统中，CPU由一个进程快速切换至另一个进程，使每个进程各运行几十或几百毫秒。严格地说，在某一个瞬间，CPU只能运行一个进程，但在1秒中内，它可能运行多个进程，这样就产生并行的错觉。伪并行就是指这种情形，以此来区分多处理器系统的真正硬件并行

### 进程模型

在进程模型中，计算机上所有可运行的软件，通常也包括操作系统，被组织成若干**顺序进程**，简称进程。一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值。CPU在进程之间来回切换，这种快速的切换称作**多道程序设计**

由于CPU在各进程之间来回快速切换，所以每个进程执行其运算的速度是不确定的

一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，转而为另一个进程提供服务。如果一个程序运行了两遍，则算作两个进程

### 进程的创建

操作系统需要有一种方式来创建进程，在通用系统中，需要有某种方法在运行时按需要创建或撤销进程  
4种主要事件会导致进程的创建：

1. 系统初始化
2. 正在运行的程序执行了创建进程的系统调用
3. 用户请求创建一个新进程
4. 一个批处理作业的初始化

从技术上看，这些所有情形中，新进程都是由于一个已存在的进程执行了一个用于创建进程的系统调用而创建的。这个进程所做的工作是，执行一个用来创建新进程的系统调用，这个系统调用通知操作系统创建一个新进程，并且直接或间接地指定在该进程中运行的程序

### 进程的终止

进程在创建后，最终会终止，通常由下列条件引起：

1. 正常退出(自愿的)
2. 出错退出(自愿的)
3. 严重错误(非自愿)
4. 被其他进程杀死(非自愿)

多数进程是由于完成了它们的工作而终止，当编译器完成了所给定程序的编译之后，编译器执行一个系统调用，通知操作系统它的工作已经完成

进程终止的第二个原因是进程发现了严重错误

进程终止的第三个原因是由进程引起的错误，通常是由于程序中的错误所致，例如，执行了一条非法指令、引用不存在的内存

第四种终止进程的原因是，某个进程执行一个系统调用通知操作系统杀死某个其他进程

### 进程的层次结构

某些系统中。当进程创建了另一个进程后，父进程和子进程就以某种形式继续保持关联，子进程自身可以创建更多的进程，组成一个进程的层次结构

在UNIX中，进程和它的所有子进程以及后裔共同组成一个进程组，当用户从键盘发出一个信号时，该信号被送给当前与键盘相关的进程组中的所有成员

Windows中没有进程层次的概念，所有进程都是地位相同的

### 进程的状态

尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但是，进程之间经常需要相互作用

当一个进程在逻辑上不能继续运行时，它就会被阻塞，典型的例子是它在等待可以使用的输入。还有可能是：一个概念上能够运行的进程被迫停止，因为操作系统调度另一个进程占用了CPU。故进程的三种状态是：

1. 运行态(该时刻进程实际占用CPU)
2. 就绪态(可运行，但因为其他进程正在运行而暂时停止)
3. 阻塞态(除非某种外部事件发生，否则进程不能运行)

前两种状态在逻辑上是类似的，处于这两种状态的进程都可以运行，只是对于第二种状态暂时没有CPU分配给它。处于第三种状态的进程不能运行，即使CPU空闲也不行

进程的三种状态之间有四种可能的转换关系：

1. 进程因为等待输入而被阻塞(运行->阻塞)
2. 调度程序选择另一个进程(运行->就绪)
3. 调度程序选择这个进程(就绪->运行)
4. 出现有效输入(阻塞->就绪)

转换2和3是由进程调度程序引起的，进程调度程序是操作系统的一部分，调度程序的主要工作就是决定应当运行哪个进程、何时运行及它应该运行多长时间

系统认为一个运行进程占有处理器的时间已经过长，决定让其他进程使用CPU时间时，会发生转换2  
在系统已经让所有进程享有了它们应有的公平待遇而重新轮到第一个进程再次占用CPU运行时，会发生转换3  
当进程等待的一个外部事件发生时，则发生转换4，如果此时没有其他进程运行，则立即触发转换3，该进程开始运行，否则该进程将处于就绪态，等待CPU空闲并且轮到它运行

### 进程的实现

为了实现进程模型，操作系统维护着一张表格(一个结构数组)，即**进程表**。每个进程占用一个进程表项，该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动

与每一I/O类关联的是一个称作**中断向量**的位置，它包含中断服务程序的入口地址

### 多道程序设计模型

## 线程

在传统操作系统中，每个进程有一个地址空间和一个控制线程。这几乎就是进程的定义。不过，经常存在在同一个地址空间中准并行运行多个控制线程的情形，这些线程就像分离的进程

### 线程的使用

人们需要多线程的主要原因是，在许多应用中同时发生着多种活动。其中某些活动随着时间的推移会被阻塞。通过将这些应用程序分解成可以准并行运行的多个顺序线程，程序设计模型会变得更简单

第二个需要多线程的理由是，由于线程比进程更轻量级，所以它们比进程更容易创建，也更容易撤销，在许多系统中，创建一个线程较创建一个进程要快10~100倍。在有大量线程需要动态和快速修改时，具有这一特性是很有用的

需要多线程的第三个原因涉及性能方面。若多个线程都是CPU密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的I/O处理，拥有多个线程允许这些活动彼此重叠进行，从而会加快应用程序执行的速度

### 经典的线程模型

进程模型基于两种独立的概念：资源分组处理与执行

进程有存放程序正文和数据以及其他资源的地址空间，这些资源中包括打开的文件、子进程、即将发生的定时器、信号处理程序、账号信息等

进程拥有一个执行的线程，通常简写为线程。在线程中有一个程序计数器，用来记录接着要执行哪一条指令。线程拥有寄存器，用来保存线程当前的工作变量。线程还拥有一个堆栈，用来记录执行历史，其中每一帧保存了一个以调用的但是还没有从中返回的过程。**进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体**

在同一个进程环境中，允许彼此之间有较大独立性的多个线程执行。在同一个进程中并行运行多个线程，是对在同一台计算机上并行运行多个进程的模拟。前者中，多个线程共享同一个地址空间和其他资源，后者中，多个进程共享物理内存、磁盘、打印机和其他资源

进程中的不同线程不像不同进程之间那样存在很大的独立性。所有的线程都有完全一样的地址空间，这意味着它们也共享同样的全局变量。由于各个线程都可以访问进程地址空间中的每一个内存地址，所以一个线程可以读、写或甚至清除另一个线程的堆栈。

线程之间是没有保护的，原因是：1.不可能 2.没有必要

不同的进程会来自不同的用户，它们彼此之间可能有敌意，一个进程总是由某个用户所拥有，该用户创建多个线程应该是为了它们之间的合作

### POSIX线程

为实现可移植的线程程序，IEEE定义了线程的标准。它定义的线程包叫做**pthread**，所有的pthread线程都有某些特性。每一个都含有一个标识符、一组寄存器和一组存储在结构中的属性。这些属性包括堆栈大小、调度参数以及其他线程需要的项目

### 在用户空间中实现线程

有两种主要的方法实现线程包：在用户空间中和内核中。

把整个线程包放在用户空间中，内核对线程包一无所知。从内核的角度考虑，就是单线程进程。这种方法最明显的优点是，用户级线程包可以在不支持线程的操作系统上实现

在用户空间管理线程时，每个进程需要有其专用的**线程表**，用来跟踪该进程中的线程。该线程表由运行时系统管理。当一个线程转换到就绪状态或阻塞状态时，在该线程表中存放重新启动该线程所需的信息，与内核在进程表中存放进程的信息完全一样

线程切换至少比陷入内核要快一个数量级，这是使用用户线程包极大的优点。进程和线程有一个关键的差别。在线程完成运行时，pthread_yield代码可以把该线程的信息保存在线程表中，进而，它可以调用线程调度程序来选择另一个要运行的线程。保存该线程状态的过程都只是本地过程，所以启动它们比进行内核调用效率更高。另一方面，不需要陷入内核，不需要上下文切换，也不需要对内存高速缓存进行刷新，这使得线程调度非常快捷

用户级线程还有一个优点。它允许每个进程有自己定制的调度算法。用户级线程还具有较好的可扩展性，这是因为在内核空间中内核线程需要一些固定表格空间和堆栈空间，如果内核线程的数量非常大就会出现问题

用户级线程包有一些明显的问题。例如，如何实现阻塞系统调用；缺页中断问题；如果一个线程开始运行，那么在该进程中的其他线程就不能运行，因为在一个单独的进程内部没有时钟中断

### 在内核中实现线程

内核支持和管理线程时，不再需要运行时系统了，另外每个进程中也没有线程表。相反，在内核中有用来记录系统中所有线程的线程表。当某个线程希望创建一个新线程或撤销一个已有线程时，它进行一个系统调用，这个系统调用通过对线程表的更新完成线程创建或撤销工作

所有能够阻塞线程的调用都以系统调用的形式实现。当一个线程阻塞时，内核可以选择运行同一个进程的另一个线程或者运行另一个进程中的线程。而在用户级线程中，运行时系统始终运行自己进程中的线程，直到内核剥夺它的CPU为止

内核线程不需要任何新的、非阻塞系统调用。如果某个进程中的线程引起了页面故障，内核可以很方便的检查该进程是否有任何其他可运行的线程，如果有，在等待所需要的页面从磁盘读入时就选择一个可运行的线程运行。这样做的缺点是系统调用的代价较大，如果线程的操作比较多就会带来很大的开销

### 混合实现

一种实现方法是使用内核级线程，然后将用户级线程与某些或全部内核线程多路复用起来。这样，程序员可以决定有多少个内核级线程和多少个用户级线程彼此多路复用。采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。如同在没有多线程能力操作系统中某个进程中的用户级线程一样，可以创建、撤销和调度这些用户级线程。每个内核级线程有一个可以轮流使用的用户级线程集合