# 进程与线程

## 进程

在任何多道程序设计系统中，CPU由一个进程快速切换至另一个进程，使每个进程各运行几十或几百毫秒。严格地说，在某一个瞬间，CPU只能运行一个进程，但在1秒中内，它可能运行多个进程，这样就产生并行的错觉。伪并行就是指这种情形，以此来区分多处理器系统的真正硬件并行

### 进程模型

在进程模型中，计算机上所有可运行的软件，通常也包括操作系统，被组织成若干**顺序进程**，简称进程。一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值。CPU在进程之间来回切换，这种快速的切换称作**多道程序设计**

由于CPU在各进程之间来回快速切换，所以每个进程执行其运算的速度是不确定的

一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，转而为另一个进程提供服务。如果一个程序运行了两遍，则算作两个进程

### 进程的创建

操作系统需要有一种方式来创建进程，在通用系统中，需要有某种方法在运行时按需要创建或撤销进程  
4种主要事件会导致进程的创建：

1. 系统初始化
2. 正在运行的程序执行了创建进程的系统调用
3. 用户请求创建一个新进程
4. 一个批处理作业的初始化

从技术上看，这些所有情形中，新进程都是由于一个已存在的进程执行了一个用于创建进程的系统调用而创建的。这个进程所做的工作是，执行一个用来创建新进程的系统调用，这个系统调用通知操作系统创建一个新进程，并且直接或间接地指定在该进程中运行的程序

### 进程的终止

进程在创建后，最终会终止，通常由下列条件引起：

1. 正常退出(自愿的)
2. 出错退出(自愿的)
3. 严重错误(非自愿)
4. 被其他进程杀死(非自愿)

多数进程是由于完成了它们的工作而终止，当编译器完成了所给定程序的编译之后，编译器执行一个系统调用，通知操作系统它的工作已经完成

进程终止的第二个原因是进程发现了严重错误

进程终止的第三个原因是由进程引起的错误，通常是由于程序中的错误所致，例如，执行了一条非法指令、引用不存在的内存

第四种终止进程的原因是，某个进程执行一个系统调用通知操作系统杀死某个其他进程

### 进程的层次结构

某些系统中。当进程创建了另一个进城后，父进程和子进程就以某种形式继续保持关联，子进程自身可以创建更多的进程，组成一个进程的层次结构

在UNIX中，进程和它的所有子进程以及后裔共同组成一个进程组，当用户从键盘发出一个信号时，该信号被送给当前与键盘相关的进程组中的所有成员

Windows中没有进程层次的概念，所有进程都是地位相同的

### 进程的状态

尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但是，进程之间经常需要相互作用

当一个进程在逻辑上不能继续运行时，它就会被阻塞，典型的例子是它在等待可以使用的输入。还有可能是：一个概念上能够运行的进程被迫停止，因为操作系统调度另一个进程占用了CPU。故进程的三种状态是：

1. 运行态(该时刻进程实际占用CPU)
2. 就绪态(可运行，但因为其他进程正在运行而暂时停止)
3. 阻塞态(除非某种外部事件发生，否则进程不能运行)

前两种状态在逻辑上是类似的，处于这两种状态的进程都可以运行，只是对于第二种状态暂时没有CPU分配给它。处于第三种状态的进程不能运行，即使CPU空闲也不行

进程的三种状态之间有四种可能的转换关系：

1. 进程因为等待输入而被阻塞(运行->阻塞)
2. 调度程序选择另一个进程(运行->就绪)
3. 调度程序选择这个进程(就绪->运行)
4. 出现有效输入(阻塞->就绪)

转换2和3是由进程调度程序引起的，进程调度程序是操作系统的一部分，调度程序的主要工作就是决定应当运行哪个进程、何时运行及它应该运行多长时间

系统认为一个运行进程占有处理器的时间已经过长，决定让其他进程使用CPU时间时，会发生转换2  
在系统已经让所有进程享有了它们应有的公平待遇而重新轮到第一个进程再次占用CPU运行时，会发生转换3  
当进程等待的一个外部事件发生时，则发生转换4，如果此时没有其他进程运行，则立即触发转换3，该进程开始运行，否则该进程将处于就绪态，等待CPU空闲并且轮到它运行

### 进程的实现

为了实现进程模型，操作系统维护着一张表格(一个结构数组)，即**进程表**。每个进程占用一个进程表项，该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动

与每一I/O类关联的是一个称作**中断向量**的位置，它包含中断服务程序的入口地址

### 多道程序设计模型

## 线程

在传统操作系统中，每个进程有一个地址空间和一个控制线程。这几乎就是进程的定义。不过，经常存在在同一个地址空间中准并行运行多个控制线程的情形，这些线程就像分离的进程

### 线程的使用

人们需要多线程的主要原因是，在许多应用中同时发生着多种活动。其中某些活动随着时间的推移会被阻塞。通过将这些应用程序分解成可以准并行运行的多个顺序线程，程序设计模型会变得更简单

第二个需要多线程的理由是，由于线程比进程更轻量级，所以它们比进程更容易创建，也更容易撤销，在许多系统中，创建一个线程较创建一个进程要快10~100倍。在有大量线程需要动态和快速修改时，具有这一特性是很有用的

需要多线程的第三个原因涉及性能方面。若多个线程都是CPU密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的I/O处理，拥有多个线程允许这些活动彼此重叠进行，从而会加快应用程序执行的速度

### 经典的线程模型

进程模型基于两种独立的概念：资源分组处理与执行

进程有存放程序正文和数据以及其他资源的地址空间，这些资源中包括打开的文件、子进程、即将发生的定时器、信号处理程序、账号信息等

进程拥有一个执行的线程，通常简写为线程。在线程中有一个程序计数器，用来记录接着要执行哪一条指令。线程拥有寄存器，用来保存线程当前的工作变量。线程还拥有一个堆栈，用来记录执行历史，其中每一帧保存了一个以调用的但是还没有从中返回的过程。**进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体**

在同一个进程环境中，允许彼此之间有较大独立性的多个线程执行。在同一个进程中并行运行多个线程，是对在同一台计算机上并行运行多个进程的模拟。前者中，多个线程共享同一个地址空间和其他资源，后者中，多个进程共享物理内存、磁盘、打印机和其他资源

进程中的不同线程不像不同进程之间那样存在很大的独立性。所有的线程都有完全一样的地址空间，这意味着它们也共享同样的全局变量。由于各个线程都可以访问进程地址空间中的每一个内存地址，所以一个线程可以读、写或甚至清除另一个线程的堆栈。

线程之间是没有保护的，原因是：1.不可能 2.没有必要

不同的进程会来自不同的用户，它们彼此之间可能有敌意，一个进程总是由某个用户所拥有，该用户创建多个线程应该是为了它们之间的合作