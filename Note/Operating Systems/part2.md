# 进程与线程

## 进程

在任何多道程序设计系统中，CPU由一个进程快速切换至另一个进程，使每个进程各运行几十或几百毫秒。严格地说，在某一个瞬间，CPU只能运行一个进程，但在1秒中内，它可能运行多个进程，这样就产生并行的错觉。伪并行就是指这种情形，以此来区分多处理器系统的真正硬件并行

### 进程模型

在进程模型中，计算机上所有可运行的软件，通常也包括操作系统，被组织成若干**顺序进程**，简称进程。一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值。CPU在进程之间来回切换，这种快速的切换称作**多道程序设计**

由于CPU在各进程之间来回快速切换，所以每个进程执行其运算的速度是不确定的

一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，转而为另一个进程提供服务。如果一个程序运行了两遍，则算作两个进程

### 进程的创建

操作系统需要有一种方式来创建进程，在通用系统中，需要有某种方法在运行时按需要创建或撤销进程  
4种主要事件会导致进程的创建：

1. 系统初始化
2. 正在运行的程序执行了创建进程的系统调用
3. 用户请求创建一个新进程
4. 一个批处理作业的初始化

从技术上看，这些所有情形中，新进程都是由于一个已存在的进程执行了一个用于创建进程的系统调用而创建的。这个进程所做的工作是，执行一个用来创建新进程的系统调用，这个系统调用通知操作系统创建一个新进程，并且直接或间接地指定在该进程中运行的程序

### 进程的终止

进程在创建后，最终会终止，通常由下列条件引起：

1. 正常退出(自愿的)
2. 出错退出(自愿的)
3. 严重错误(非自愿)
4. 被其他进程杀死(非自愿)

多数进程是由于完成了它们的工作而终止，当编译器完成了所给定程序的编译之后，编译器执行一个系统调用，通知操作系统它的工作已经完成

进程终止的第二个原因是进程发现了严重错误

进程终止的第三个原因是由进程引起的错误，通常是由于程序中的错误所致，例如，执行了一条非法指令、引用不存在的内存

第四种终止进程的原因是，某个进程执行一个系统调用通知操作系统杀死某个其他进程

### 进程的层次结构

某些系统中。当进程创建了另一个进程后，父进程和子进程就以某种形式继续保持关联，子进程自身可以创建更多的进程，组成一个进程的层次结构

在UNIX中，进程和它的所有子进程以及后裔共同组成一个进程组，当用户从键盘发出一个信号时，该信号被送给当前与键盘相关的进程组中的所有成员

Windows中没有进程层次的概念，所有进程都是地位相同的

### 进程的状态

尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但是，进程之间经常需要相互作用

当一个进程在逻辑上不能继续运行时，它就会被阻塞，典型的例子是它在等待可以使用的输入。还有可能是：一个概念上能够运行的进程被迫停止，因为操作系统调度另一个进程占用了CPU。故进程的三种状态是：

1. 运行态(该时刻进程实际占用CPU)
2. 就绪态(可运行，但因为其他进程正在运行而暂时停止)
3. 阻塞态(除非某种外部事件发生，否则进程不能运行)

前两种状态在逻辑上是类似的，处于这两种状态的进程都可以运行，只是对于第二种状态暂时没有CPU分配给它。处于第三种状态的进程不能运行，即使CPU空闲也不行

进程的三种状态之间有四种可能的转换关系：

1. 进程因为等待输入而被阻塞(运行->阻塞)
2. 调度程序选择另一个进程(运行->就绪)
3. 调度程序选择这个进程(就绪->运行)
4. 出现有效输入(阻塞->就绪)

转换2和3是由进程调度程序引起的，进程调度程序是操作系统的一部分，调度程序的主要工作就是决定应当运行哪个进程、何时运行及它应该运行多长时间

系统认为一个运行进程占有处理器的时间已经过长，决定让其他进程使用CPU时间时，会发生转换2  
在系统已经让所有进程享有了它们应有的公平待遇而重新轮到第一个进程再次占用CPU运行时，会发生转换3  
当进程等待的一个外部事件发生时，则发生转换4，如果此时没有其他进程运行，则立即触发转换3，该进程开始运行，否则该进程将处于就绪态，等待CPU空闲并且轮到它运行

### 进程的实现

为了实现进程模型，操作系统维护着一张表格(一个结构数组)，即**进程表**。每个进程占用一个进程表项，该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动

与每一I/O类关联的是一个称作**中断向量**的位置，它包含中断服务程序的入口地址

### 多道程序设计模型

## 线程

在传统操作系统中，每个进程有一个地址空间和一个控制线程。这几乎就是进程的定义。不过，经常存在在同一个地址空间中准并行运行多个控制线程的情形，这些线程就像分离的进程

### 线程的使用

人们需要多线程的主要原因是，在许多应用中同时发生着多种活动。其中某些活动随着时间的推移会被阻塞。通过将这些应用程序分解成可以准并行运行的多个顺序线程，程序设计模型会变得更简单

第二个需要多线程的理由是，由于线程比进程更轻量级，所以它们比进程更容易创建，也更容易撤销，在许多系统中，创建一个线程较创建一个进程要快10~100倍。在有大量线程需要动态和快速修改时，具有这一特性是很有用的

需要多线程的第三个原因涉及性能方面。若多个线程都是CPU密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的I/O处理，拥有多个线程允许这些活动彼此重叠进行，从而会加快应用程序执行的速度

### 经典的线程模型

进程模型基于两种独立的概念：资源分组处理与执行

进程有存放程序正文和数据以及其他资源的地址空间，这些资源中包括打开的文件、子进程、即将发生的定时器、信号处理程序、账号信息等

进程拥有一个执行的线程，通常简写为线程。在线程中有一个程序计数器，用来记录接着要执行哪一条指令。线程拥有寄存器，用来保存线程当前的工作变量。线程还拥有一个堆栈，用来记录执行历史，其中每一帧保存了一个以调用的但是还没有从中返回的过程。**进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体**

在同一个进程环境中，允许彼此之间有较大独立性的多个线程执行。在同一个进程中并行运行多个线程，是对在同一台计算机上并行运行多个进程的模拟。前者中，多个线程共享同一个地址空间和其他资源，后者中，多个进程共享物理内存、磁盘、打印机和其他资源

进程中的不同线程不像不同进程之间那样存在很大的独立性。所有的线程都有完全一样的地址空间，这意味着它们也共享同样的全局变量。由于各个线程都可以访问进程地址空间中的每一个内存地址，所以一个线程可以读、写或甚至清除另一个线程的堆栈。

线程之间是没有保护的，原因是：1.不可能 2.没有必要

不同的进程会来自不同的用户，它们彼此之间可能有敌意，一个进程总是由某个用户所拥有，该用户创建多个线程应该是为了它们之间的合作

### POSIX线程

为实现可移植的线程程序，IEEE定义了线程的标准。它定义的线程包叫做**pthread**，所有的pthread线程都有某些特性。每一个都含有一个标识符、一组寄存器和一组存储在结构中的属性。这些属性包括堆栈大小、调度参数以及其他线程需要的项目

### 在用户空间中实现线程

有两种主要的方法实现线程包：在用户空间中和内核中。

把整个线程包放在用户空间中，内核对线程包一无所知。从内核的角度考虑，就是单线程进程。这种方法最明显的优点是，用户级线程包可以在不支持线程的操作系统上实现

在用户空间管理线程时，每个进程需要有其专用的**线程表**，用来跟踪该进程中的线程。该线程表由运行时系统管理。当一个线程转换到就绪状态或阻塞状态时，在该线程表中存放重新启动该线程所需的信息，与内核在进程表中存放进程的信息完全一样

线程切换至少比陷入内核要快一个数量级，这是使用用户线程包极大的优点。进程和线程有一个关键的差别。在线程完成运行时，pthread_yield代码可以把该线程的信息保存在线程表中，进而，它可以调用线程调度程序来选择另一个要运行的线程。保存该线程状态的过程都只是本地过程，所以启动它们比进行内核调用效率更高。另一方面，不需要陷入内核，不需要上下文切换，也不需要对内存高速缓存进行刷新，这使得线程调度非常快捷

用户级线程还有一个优点。它允许每个进程有自己定制的调度算法。用户级线程还具有较好的可扩展性，这是因为在内核空间中内核线程需要一些固定表格空间和堆栈空间，如果内核线程的数量非常大就会出现问题

用户级线程包有一些明显的问题。例如，如何实现阻塞系统调用；缺页中断问题；如果一个线程开始运行，那么在该进程中的其他线程就不能运行，因为在一个单独的进程内部没有时钟中断

### 在内核中实现线程

内核支持和管理线程时，不再需要运行时系统了，另外每个进程中也没有线程表。相反，在内核中有用来记录系统中所有线程的线程表。当某个线程希望创建一个新线程或撤销一个已有线程时，它进行一个系统调用，这个系统调用通过对线程表的更新完成线程创建或撤销工作

所有能够阻塞线程的调用都以系统调用的形式实现。当一个线程阻塞时，内核可以选择运行同一个进程的另一个线程或者运行另一个进程中的线程。而在用户级线程中，运行时系统始终运行自己进程中的线程，直到内核剥夺它的CPU为止

内核线程不需要任何新的、非阻塞系统调用。如果某个进程中的线程引起了页面故障，内核可以很方便的检查该进程是否有任何其他可运行的线程，如果有，在等待所需要的页面从磁盘读入时就选择一个可运行的线程运行。这样做的缺点是系统调用的代价较大，如果线程的操作比较多就会带来很大的开销

### 混合实现

一种实现方法是使用内核级线程，然后将用户级线程与某些或全部内核线程多路复用起来。这样，程序员可以决定有多少个内核级线程和多少个用户级线程彼此多路复用。采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。如同在没有多线程能力操作系统中某个进程中的用户级线程一样，可以创建、撤销和调度这些用户级线程。每个内核级线程有一个可以轮流使用的用户级线程集合

### 调度程序激活机制

调度程序激活工作的目标是模拟内核线程的功能，但是为线程包提供通常在用户空间中才能实现的更好的性能和更大的灵活性

由于避免了在用户空间和内核空间之间的不必要转换，从而提高了效率。当使用调度程序激活机制时，内核给每个进程安排一定数量的虚拟处理器，并且让用户空间运行时系统将线程分配到处理器上

该机制工作的基本思路是，当内核了解到一个线程被阻塞之后，内核通知该进程的运行时系统，并且在堆栈中以参数形式传递有问题的线程编号和所发生事件的一个描述。内核通过在一个已知的起始地址启动运行时系统，从而发出了通知。这个机制称为**上行调用**

一旦激活，运行时系统就重新调度其线程：把当前线程标记为阻塞并从就绪表中取出另一个线程，设置其寄存器然后再启动。当内核知道原来的线程又可运行时，内核就又一次上行调用运行时系统，通知它。此时运行时系统按照自己的判断立即重启该线程或放入就绪表中稍后运行

在某个用户线程运行的同时发生一个硬件中断时，被中断的CPU切换进内核态。如果被中断的进程对引起中断的事件不感兴趣，中断处理结束后就把被中断的线程恢复到中断前的状态。如果感兴趣，那么被中断的线程就不再启动，而是挂起。运行时系统则启动对应的虚拟CPU，被中断线程的状态保存在堆栈中。随后，运行时系统决定在该CPU上调度哪个线程

### 弹出式线程

处理到来的消息的传统方法是将进程或线程阻塞在一个receive系统调用上，等待消息的到来。当消息到达时，该系统调用接收消息，并打开消息检查其内容，然后进行处理

另一种完全不同的处理方法中，一个消息的 到达导致系统创建一个处理该消息的线程，这种线程称为**弹出式线程**。弹出式线程的关键好处是，由于这种线程相当新，没有历史，没有必须存储的寄存、堆栈等内容，每个线程从全新开始，每个线程彼此之间完全一样。使用弹出式线程的结果是，消息到达与处理开始之间的时间非常短

在使用弹出式线程之前，需要提前进行计划。例如，哪个进程中的线程先运行；如果系统支持在内核上下文中运行线程，线程就有个可能在那里运行。在内核空间中运行弹出式线程通常比在用户空间中容易且快捷，而且内核空间中的弹出式线程可以很容易的访问所有的表格和I/O设备。但另一方面，出错的内核线程会比出错的用户线程造成更大的损害

### 使单线程代码多线程化

单线程代码改写成多线程的一个问题是，对线程而言是全局变量，并不是对整个程序也是全局的；另一个问题是，有许多库过程并不是可重入的；最后一个问题是堆栈的管理

## 进程间通信

进程间通信有三个问题，第一个是一个进程如何把信息传递给另一个；第二个是确保两个或更多的进程在关键活动中不会出现交叉；第三个问题与正确的顺序有关。信息传递对线程而言比较容易，因为它们共享一个地址空间，在不同地址空间需要通信的线程属于不同进程之间的通信

### 竞争条件

一些操作系统中，协作的进程可能共享一些彼此都能读写的公用存储区，在两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序的这种情况，称为**竞争条件**

### 临界区

凡是涉及共享资源的情况都会引发与竞争条件类似的错误，要避免这种错误，关键是找出某种途径来阻止多个进程同时读写共享的数据。所以我们需要**互斥**，即以某种手段确保当一个进程在使用一个共享变量或文件时，其他进程不能做同样的操作

一个进程的一部分时间做内部计算或一些不会引发竞争条件的操作，在某些时候进程可能需要访问共享内存、共享文件或执行一些会导致竞争的操作。对共享内存进行访问的程序片段称作**临界区域**或**临界区**，如果我们能够使两个进程不可能同时处于临界区中，就能避免竞争条件

这样避免了竞争条件，但还不能保证使用共享数据的并发进程能够正确和高效的协作，一个好的解决方案需要满足以下条件：

1. 任何两个进程不能同时处于其临界区
2. 不应对CPU的速度和数量做任何假设
3. 临界区外运行的进程不得阻塞其他进程
4. 不得使用进程无期限等待进入临界区

### 忙等待的互斥

#### 屏蔽中断

在单处理器系统中，最简单的方法是使每个进程在刚刚进入临界区后立即屏蔽所有中断，并在就要离开之前再打开中断。屏蔽中断后，时钟中断也被屏蔽，而CPU只有发生时钟中断或其他中断才会进行进程切换。这样，在屏蔽中断之后CPU就不会被切换到其他进程，于是一旦某个进程屏蔽中断之后，它就可以检查和修改共享内存而不必担心其他进程介入

这种方案并不好，因为把屏蔽中断的权利交给用户进程是不明智的。对于单处理器系统，可能导致整个系统终止，对多处理器系统，屏蔽中断只对执行disable指令的CPU有效，其他CPU仍可以访问共享内存。

#### 锁变量

一种软件解决方案是，设想由一个共享(锁)变量初始值为0，当一个进程想进入其临界区时，它首先测试这把锁。如果该锁的值为0，则该进程将其设置为1并进入临界区，若这把锁的值已经为1，则该进程将等待直到其值变为0

这种方案包含了与假脱机目录一样的疏漏。假设一个进程读出锁变量的值并发现它为0，而恰好在它将其值设置为1之前，另一个进程被调度运行，将该锁变量设置为1。当第一个进程再次运行时，它同样也将该锁设置为1，则此时同时有两个进程进入临界区

#### 严格轮换法

连续测试一个变量直到某个值出现为止，称为**忙等待**，用于忙等待的锁，称为**自旋锁**

有一个整型变量turn，初始值为0，用于记录轮到哪个进程进入临界区，并检查或更新共享内存。进程0离开临界区时，它将turn的值设置为1，以便允许进程1进入其临界区，进程1很快离开临界区，turn的值又被设置为0。突然，进程0结束了非临界区的操作并且返回到循环的开始，但是它不能进入临界区，因为turn的当前值为1，而此时进程1还在忙于非临界区的操作，进程0只有继续while循环，直到进程1把turn的值改为0。这说明在一个进程比另一个慢了很多的情况下，轮流进入临界区并不是一个好办法

这种情况违反了前述的条件3：进程0被一个临界区外的进程阻塞

#### Peterson解法

#### TSL指令