# 第二章

## 应用层协议原理

研发网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序  
例如，在web应用程序中，有两个互相通信的不同的程序，一个是运行在用户主机上的浏览器程序，另一个是运行在web服务器主机上的web服务器程序

### 网络应用程序体系结构

现代网络应用程序中所使用的两种主流体系结构：**客户-服务器体系结构**或**对等(P2P)体系结构**

#### 客户-服务器体系结构

在此体系结构中，有一个总是打开的主机称为**服务器**，它服务于来自许多其他称为**客户**的主机的请求  
例如，web应用程序中总是打开的web服务器服务于来自浏览器的请求，当web服务器接收到来自某客户对某对象的请求时，它向该客户发送所请求的对象作为响应

客户-服务器体系结构中，客户相互之间不直接通信

客户-服务器体系结构的另一个特征是该服务器具有固定的、周知的地址，该地址称为IP地址

#### P2P体系结构

在此体系结构中，对位于数据中心的专用服务器有最小的依赖，应用程序在间断连接的主机对之间使用直接通信，这些主机被称为**对等方**

因为这种对等方通信不必通过专门的服务器，该体系结构被称为对等方到对等方的，许多流量密集型应用都是P2P体系结构

P2P体系结构的特性之一是**自扩展性**，例如，在一个P2P文件共享应用中，每个对等方都由于请求文件产生工作负载，但每个对等方通过向其他对等方分发文件也为系统增加服务能力

### 进程通信

在两个不同端系统上的进程，通过跨越计算机网络交换报文而相互通信，发送进程生成并向网络中发送报文，接收进程接收这些报文并可能通过回送报文进行响应

1. **客户和服务器进程**

    在一对进程之间的通信会话场景中，发起通信的进程被标识为**客户**，在会话开始时等待联系的进程是**服务器**

2. **进程与计算机网络之间的接口**

    进程通过一个称为**套接字**的软件接口向网络发送报文和从网络接收报文

    套接字是同一台主机内应用层与运输层之间的接口，由于该套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的**应用程序编程接口**。应用程序开发者可以控制套接字在应用层端的一切，但是对该套接字的运输层端几乎没有控制权，仅限于：选择运输层协议、设定几个运输层参数

3. **进程寻址**

    在一台主机上运行的进程为了向在另一台主机上运行的进程发送分组，接收进程需要有一个地址。为了标识该接收进程，需要定义两种信息：主机的地址、在目的主机中指定接收进程的标识符

    在Internet中，主机由其IP地址标识，它是一个32比特的量。除了知道报文发送目的地的主机地址外，发送进程还必须指定运行在接收主机上的接收进程(具体地说，接收套接字)，因为一台主机能够运行许多网络应用

### 可供应用程序使用的运输服务

我们大体能够从四个方面对应用程序服务进行分类：可靠数据传输、吞吐量、定时、安全性

1. **可靠数据传输**

    如果一个协议提供了确保数据交付服务(由应用程序的一端发送的数据正确、完全地交付给该应用程序的另一端)，就认为提供了可靠数据传输。当一个运输协议提供这种服务时，发送进程只要将其数据传递进套接字，就可以完全相信该数据将能无差错地到达接收进程

2. **吞吐量**

    一个应用程序能够请求r比特/秒的确保吞吐量，并且该运输协议能够确保可用吞吐量总是为至少r比特/秒。如果运输协议不能提供这种吞吐量，该应用程序或以较低速率进行编码，或可能必须放弃发送，因为接收所需吞吐量的一半是几乎没有或根本没有用处的。居于吞吐量要求的应用程序被称为**一个带宽敏感的应用**

3. **定时**

    运输层协议能够提供定时保证，如同具有吞吐量保证那样，定时保证能够以多种形式实现。例如，发送方注入进套接字中的每个比特到达接收方的套接字不迟于100ms

4. **安全性**

    运输协议能够为应用程序提供一种或多种安全性服务。例如，在发送主机中，运输协议能够加密由发送进程茶u念书的所有数据，在接收主机中，运输层协议能够在将数据交付给接收进程之前解密这些数据。这种服务将在发送和接收进程之间提供机密性，以防该数据以某种方式在这两个进程之间被观察到

### Internet提供的运输服务

Internet为应用程序提供两个运输层协议，即UDP和TCP

#### TCP服务

TCP服务模型包括面向连接服务和可靠数据传输服务

- 面向连接的服务：在应用层数据报文开始流动之前，TCP让客户和服务器互相交换运输层控制信息，这个所谓的握手过程提醒客户和服务器，让它们为大量分组的到来做好准备。在握手阶段后，一个TCP连接就在两个进程的套接字之间建立了。这条连接是全双工的，即连接双方的进程可以在此连接上同时进行报文收发，当应用程序结束报文发送时，必须拆除该连接

- 可靠的数据传送服务：通信进程能够依靠TCP，无差错、按适当顺序交付所有发送的数据。当应用程序的一端将字节流传进套接字时，它能够依靠TCP将相同的字节流交付给接收方的套接字，而没有字节的丢失和冗余

TCP协议还具有拥塞控制机制，当发送方和接收方之间的网络出现拥塞时，TCP的拥塞控制机制会抑制发送进程

#### UDP服务

UDP是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。UDP是无连接的，因此在两个进程通信前没有握手过程。UDP协议提供一种不可靠数据传送服务，UDP协议不保证报文将到达接受进程，不仅如此，到达接受进程的报文也可能是乱序到达的

UDP没有包括拥塞控制机制

#### Internet运输协议所不提供的服务

吞吐量和定时保证在目前的Internet运输协议上并没有提供

### 应用层协议

应用层协议定义了运行在不同端系统上的应用程序如何相互传递报文。特别是应用层协议定义了：

- 交换的报文类型，例如请求报文和相应报文
- 各种报文类型的语法，如报文中的各个字段及这些字段是如何描述的
- 字段的语义，即这些字段中的信息和含义
- 确定一个进程何时以及如何发送报文，对报文进行响应的规则

有些应用层协议是由RFC文档定义的，因此它们位于公共域中，例如HTTP

应用层协议只是网络应用的一部分，例如，Web是一种客户-服务器应用，组成包括文档格式的标准(HTML)、Web浏览器、Web服务器以及一个应用层协议

## Web和HTTP

### HTTP概况

Web的应用层协议是**超文本传输协议(HTTP)**，它是Web的核心。HTTP由两个程序实现：一个客户程序和一个服务器程序，它们运行在不同的端系统中，通过交换HTTP报文进行会话

HTTP定义了Web客户向Web服务器请求Web页面的方式，以及服务器向客户传送Web页面的方式，其基本思想是：当用户请求一个Web页面时，浏览器向服务器发出对该页面中所包含对象的HTTP请求报文，服务器接收到请求并用包含这些对象的HTTP响应报文进行响应

HTTP使用TCP作为它的支撑运输协议。一旦客户向它的套接字接口发送了一个请求报文，该报文就脱离了客户控制并进入TCP的控制。HTTP协议不担心数据丢失，也不关注TCP从网络的数据丢失和乱序故障中恢复的细节，这是分层体系结构最大的优点

服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息。因为HTTP服务器并不保存关于客户的任何信息，所以我们说HTTP是一个**无状态协议**

### 非持续连接和持续连接

非持续连接：每个请求/响应对是经一个**单独的**TCP连接发送的  
持续链接：所有的请求及其响应经**相同的**TCP连接发送

HTTP既能够使用非持续连接，也能够使用持续连接，尽管HTTP在其默认方式下使用持续连接

#### 采用非持续连接的HTTP

每个TCP连接在服务器发送一个对象后关闭，即该连接并不为其他的对象而持续下来，每个TCP连接只传输一个请求报文和一个响应报文

往返时间(RTT)的定义是，指一个短分组从客户到服务器然后再返回客户所花费的时间。RTT包括分组传播时延，分组在中间路由器和交换机上的排队时延以及分组处理时延

当用户点击一个超链接会发生的情况：浏览器在它和Web服务器之间发起一个TCP连接；涉及一个“三次握手”过程，即客户向服务器发送一个小TCP报文段，服务器用一个小TCP报文段做出确认和响应，最后客户向服务器返回确认。三次握手中前两个部分所耗费的时间占用了一个RTT。完成前两个部分后，客户结合三次握手的第三部分向该TCP连接发送一个HTTP请求报文。一旦该请求报文到达服务器，服务器就在该TCP连接上发送HTML文件。该HTTP请求/响应用去了另一个RTT

#### 采用持续连接的HTTP

非持续连接有一些缺点：

1. 必须为每一个请求的对象建立和维护一个全新的连接。对于每个这样的连接，客户和服务器中都要分配TCP的缓冲区和保持TCP变量，给Web服务器带来了严重负担

2. 每一个对象经受两倍RTT的交付时延，即一个RTT用于创建TCP，另一个RTT用于请求和接收一个对象

在采用持续连接的情况下，服务器在发送响应后保持该TCP连接的打开。在相同的客户和服务器之间，后续的请求和响应报文能够通过相同的连接进行传送。一般来说，如果一条连接经过一定时间间隔仍未被使用，HTTP服务器就关闭该连接

### HTTP报文格式

HTTP规范中包含了对HTTP报文格式的定义。HTTP报文有两种：请求报文和响应报文

#### HTTP请求报文

eg:

*GET /somedir/page.html HTTP/1.1  
Host: www.someschool.edu  
Connection: close  
User-agent: Mozilla/5.0  
Accept-language: fr*

HTTP请求报文的第一行叫做**请求行**，其后继的行叫做**首部行**。请求行有三个字段：方法字段、URL字段和HTTP版本字段。方法字段可以取不同的值，包括GET、POST、HEAD、PUT和DELETE。绝大部分的HTTP请求报文使用GET方法。当浏览器请求一个对象时，使用GET方法，在URL字段带有请求对象的标识。范例中，正在请求对象/somedir/page.html。其版本字段是自解释的

范例的首部行Host: www.someschool.edu指明了对象所在的主机。该首部行提供的信息是Web代理高速缓存所要求的。通过包括Connection: close首部行，该浏览器告诉服务器不要麻烦地使用持续连接，它要求服务器在发送完被请求的对象后就关闭这条连接。User-agent:首部行用来指明用户代理，即向服务器发送请求的浏览器类型。最后，Accept-language:首部行表示用户想得到该对象的语言版本，如果服务器中没有这样的对象，服务器将发送它的默认版本

请求报文的通用格式：除了请求行、首部行和空行，在空行后有一个**实体体**。使用GET方法时实体体为空，而使用POST方法时才使用该实体体

#### HTTP响应报文

eg:

*HTTP/1.1 200 OK  
Connection: close 
Date: Tue, 18 Aug 2015 15:44:04 GMT  
Server: Apache/2.2.3 (CentOS)  
Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT  
Content-Length: 6821  
Content-Type: text/html  

(data data data data data ...)*

本例的响应报文有三个部分，一个初始**状态行**，六个**首部行**，然后是**实体体**。实体体部分是报文的主要部分，即它包含了所请求的对象本身(表示为data data data data data ...)。状态行有3个字段：协议版本字段、状态码和相应状态信息。本例中，状态行指示服务器正在使用HTTP/1.1，并且一切正常

本例的首部行，服务器用Connection: close首部行告诉客户，发送完报文后将关闭该TCP连接。Date: 首部行指示服务器产生并发送该响应报文的日期和时间，这个时间不是指对象创建或最后修改的时间，而是服务器从它的文件系统中检索到该对象，将该对象插入响应报文，并发送该响应报文的时间。Server: 首部行指示该报文是由一台Apache Web服务器产生的，它类似于HTTP请求报文中的User-agent: 首部行。Last-Modified: 首部行指示了对象创建或者最后修改的时间和日期。Content-Length: 首部行指示了被发送对象中的字节数。Content-Type: 首部行指示了实体体中的对象是HTML文本

响应报文的通用格式：状态行、首部行、空行和实体体

### 用户与服务器的交互：cookie

HTTP使用了cookie，cookie允许站点对用户进行跟踪。

cookie技术有4个组件：

1. 在HTTP响应报文中的一个cookie首部行
2. 在HTTP请求报文中的一个cookie首部行
3. 在用户端系统中保留有一个cookie文件，并由用户的浏览器进行管理
4. 位于Web站点的一个后端数据库

### Web缓存

**Web缓存器**也叫**代理服务器**，是能够代表初始Web服务器来满足HTTP请求的网络实体。Web缓存器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本。可以配置用户的浏览器，使得用户的所有HTTP请求首先指向Web缓存器，一旦某浏览器被配置，每个对某对象的浏览器请求首先被定向到该Web缓存器，比如：

1. 浏览器创建一个到Web缓存器的TCP连接，并向Web缓存器中的对象发送一个HTTP请求
2. Web缓存器进行检查，看看本地是否存储了该对象副本。如果有，Web缓存器就向客户浏览器用HTTP响应报文返回该对象
3. 如果Web缓存器中没有该对象，它就打开一个与该对象的初始服务器的TCP连接。Web缓存器则在这个缓存器到服务器的TCP连接上发送一个该对象的HTTP请求。收到该请求后，初始服务器向该Web缓存器发送具有该对象的HTTP响应
4. 当Web缓存器接收到该对象时，它在本地存储空间存储一份副本，并向客户的浏览器用HTTP响应报文发送该副本

在Internet上部署Web缓存器有两个原因。首先，Web缓存器可以大大减少对客户请求的响应时间，特别是客户与初始服务器之间的瓶颈带宽远低于客户与Web缓存器之间的瓶颈带宽时更是如此。如果客户与Web缓存器之间有一个高速连接，并且如果用户所请求的对象在Web缓存器上，则Web缓存器可以迅速将该对象交付给用户。其次，Web缓存器能够大大减少一个机构的接入链路到Internet的通信量。此外，Web缓存器能从整体上大大减低Internet上的Web流量

### 条件GET方法

如果：请求报文使用GET方法；并且请求报文中包含一个“If-Modified-Since：”首部行，那么这个HTTP请求报文就是一个条件GET请求报文，If-Modified-Since： 首部行的值等于上一次的响应报文中Last-Modified： 首部行的值。仅当自指定日期后该对象被修改过，才发送该对象

## Internet中的电子邮件

电子邮件有3个主要组成部分：用户代理、邮件服务器和简单邮件传输协议

用户代理允许用户阅读、回复、转发、保存和撰写报文

邮件服务器形成了电子邮件体系结构的核心。每个接收方在其中的某个邮件服务器上有一个邮箱，邮箱管理和维护着发送给他的报文。一个典型的邮件发送过程是：从发送方A的用户代理开始，传输到发送方的邮件服务器，再传输到接收方B的邮件服务器，然后在这里被分发到接收方的邮箱中。如果A的服务器不能将邮件交付给B的服务器，A的邮件服务器再一个**报文队列**中保持该报文并在以后尝试再次发送，如果几天后仍不能成功，服务器就删除该报文并以电子邮件的形式通知发送方A

SMTP时电子邮件中主要的应用层协议。它使用TCP可靠数据传输服务，从发送方的邮件服务器向接收方的邮件服务器发送邮件。SMTP有两个部分：运行在发送方邮件服务器的客户端和运行在接收方邮件服务器的服务器端。每台邮件服务器上既运行SMTP的客户端也运行SMTP的服务器端

### SMTP

SMTP一般不使用中间邮件服务器发送邮件。如果对方的邮件服务器没有开机，传输报文会保留在发送方的邮件服务器上并等待新的尝试，这意味着邮件并不在中间的某个邮件服务器存留

### 与HTTP的对比

HTTP从Web服务器向Web客户传送文件；SMTP从一个邮件服务器向另一个邮件服务器传送文件。持续的HTTP和SMTP都使用持续连接。两者之间有一些共同特征，也有一些重要区别。HTTP主要是一个**拉协议**，即在方便的时候，某些人在Web服务器上装载信息，用户使用HTTP从该服务器拉取这些信息。SMTP基本上是一个**推协议**，即发送邮件服务器把文件推向接收邮件服务器

### 邮件报文格式

eg:

*From: alice @crepes.fr  
To: bob @hamburger.edu  
Subject: Searching for the meaning of life.*

每个首部行必须含有一个From: 首部行和一个To: 首部行。在报文首部之后，紧接着一个空白行，然后是以ACSII格式表示的报文体

### 邮件访问协议

现代邮件访问使用了一种客户-服务器体系结构，即用户通过在用户端系统上运行的客户程序来阅读电子邮件。但用户的PC不能一直保持在线。典型的用户通常在本地PC运行一个用户代理程序，而它访问存储在总是保持开机的共享邮件服务器上的邮箱

发送邮件的过程：A的用户代理用SMTP将邮件推入到A的邮件服务器，A的邮件服务器再用SMTP将该邮件中继到B的邮件服务器。由于SMTP是一个推协议，取报文是一个拉操作，B的用户代理不能使用SMTP得到报文。目前有POP3、IMAP和HTTP这些邮件访问协议解决这个问题

1. POP3

    POP3是一个极为简单的邮件访问协议，所以功能相当有限。当用户代理打开了一个到邮件服务器端口110上的TCP连接后，POP3就开始工作。POP3按照三个阶段进行工作：特许、事务处理以及更新。

    特许阶段中，用户代理发送用户名和口令以鉴别用户。  
    事务处理阶段中，用户代理取回报文，这个阶段用户代理还可以对报文做删除标记，取消报文删除标记，获取邮件的统计信息  
    更新阶段出现在客户发出了quit命令之后，目的是结束该POP3对话，这时该邮件服务器删除那些被标记为删除的报文

    POP3的工作方式有“下载并删除”和“下载并保留”。下载并删除方式中，用户代理首先请求服务器列出所有存储的报文的长度，接着用户代理从服务器取回并删除每逢邮件。但这种方式存在的问题是邮件接收方可能是移动的，下载并删除后就不能在其他机器上下载。使用下载并保留方式，用户代理下载某邮件后，该邮件仍保留在邮件服务器上

2. IMAP

    使用POP3访问时，用户将邮件下载到本地主机后，可以建立邮件文件夹进行报文移动、查询。但这种存放在本地主机上的方式不能进行远程管理

    IMAP服务器把每个报文与一个文件夹联系起来；当报文第一次到达服务器时，它与接收人的INBOX文件夹相关联。收件人能够把邮件移到一个用户创建的文件夹中，阅读邮件，删除邮件等。IMAP为用户提供了创建文件夹、移动邮件、查询邮件的命令，与POP3不同，IMAP服务器维护了IMAP绘画的用户状态信息

    IMAP的另一个特性是具有允许用户代理获取报文某些部分的命令，例如，可以只读取一个报文的报文首部

3. 基于Web的电子邮件

    使用这种服务，用户代理就是普通的浏览器，用户和他远程邮箱之间的通信通过HTTP进行。例如，当用户想从他的邮箱中访问一个报文时，该报文从用户的邮件服务器发送到他的浏览器使用的是HTTP；当发件人要发送一封邮件时，该邮件从用户的浏览器发送到他的邮件服务器使用的也是HTTP。但是发送方和接收方的邮件服务器之间仍使用SMTP

## DNS：因特网的目录服务

Internet上的主机可以使用多种方式进行标识，一种标识方法是使用**主机名**，如www.google.com。然而主机名几乎没有提供关于主机在Internet中位置的信息，况且主机名可能由不定长的字母数字组成，路由器难以处理。由于这些原因，主机也可以使用所谓IP地址进行标识

### DNS提供的服务

人们喜欢便于记忆的主机名标识方式，路由器喜欢定长的、有着层次结构的IP地址。所以我们需要一种能进行主机名到IP地址转换的目录服务，这就是**域名系统**的主要任务。  
DNS是：

1. 一个由分层的**DNS服务器**实现的分布式数据库
2. 一个使得主机能够查询分布式数据库的应用层协议。DNS协议运行在UDP之上，使用53号端口

DNS通常是由其他应用层协议所使用的，包括HTTP、SMTP和FTP，将用户提供的主机名解析为IP地址。但DNS会给使用它的Internet应用带来额外的时延，不过，想获得的IP地址通常就缓存在一个“附近的”DNS服务器中，这有助于减少DNS的网络流量和DNS的平均时延

除了主机名到IP地址的转换外，DNS还提供了一些重要的服务：

1. 主机别名。有着复杂主机名的主机能够拥有一个或多个别名。例如，一台名为relay1.west-coast.enterprise.com的主机，可能还有两个别名为enterprise.com和www.enterprise.com。在这种情况下，relay1.west-coast.enterprise.com也称为**规范主机名**。主机别名比主机规范名更加容易记忆。应用程序可以调用DNS来获得主机别名对应的规范主机名和主机的IP地址

2. 邮件服务器别名。邮件服务器的主机名可能十分复杂，电子邮件应用程序可以调用DNS，对提供的主机别名进行解析，以获得该主机的规范主机名及其IP地址，MX记录允许公司的邮件服务器和Web服务器使用相同(别名化)的主机名。

3. 负载分配。DNS也用于在冗余的服务器之间进行负载分配。繁忙的站点被冗余分布在多台服务器上，每台服务器均运行在不同的端系统上，每个都有有着不同的IP地址。由于这些冗余的Web服务器，一个IP地址集合因为与一个规范主机名相联系。DNS数据库中存储着这些IP地址集合。当客户对映射到某地址集合的名字发出一个DNS请求时，该服务器用IP地址的整个集合进行响应，但在每个回答中循环这些地址次序。因为客户通常总是向IP地址排在最前面的服务器发送HTTP请求报文，所以DNS就在所有这些冗余的Web服务器之间循环分配了负载

### DNS工作机理概述

假设运行在用户主机上的某些应用程序需要将主机名转换为IP地址。这些应用程序将调用DNS的客户端，并指明需要被转换的主机名。用户主机上的DNS接收到后，向网络中发送了一个DNS查询报文。所有的DNS请求和回答报文使用UDP数据报经端口53发送。经过若干毫秒到若干秒的时延后，用户主机上的DNS接收到一个提供所希望映射的DNS回答报文。这个映射结果被传递到调用DNS的应用程序。

DNS的一种简单设计是在Internet上只使用一个DNS服务器，该服务器包含所有的映射。在这种集中式设计中，客户直接将所有查询直接发往单一的DNS服务器，同时该DNS服务器直接对所有的查询客户做出相应。这种集中式设计不适用于当今的Internet，其问题包括：

1. 单点故障。如果该DNS服务器崩溃，整个Internet随之瘫痪
2. 通信容量。单个DNS服务器不得不处理所有的DNS查询
3. 远距离的集中式数据库。单个DNS服务器不可能“邻近”所有查询客户，这将导致严重的时延
4. 维护。单个DNS服务器不得不为所有的Internet主机保留记录，这不仅使这个中央数据库庞大，而且它还不得不为解决每个新添加的主机而频繁更新

#### 分布式、层次数据库

DNS使用了大量的DNS服务器，它们以层次方式组织，并且分布在全世界范围内。没有一台DNS服务器拥有Internet上所有主机的映射。大致来说，由3中类型的DNS服务器：根DNS服务器、顶级域(TLD)DNS服务器和权威DNS服务器。假定一个DNS客户要决定主机名www.amazon.com的IP地址，将发生下列事件：客户首先与根服务器之一联系，它将返回顶级域名com的TLD服务器的IP地址；该客户则与这些TLD服务器之一联系，它将为amazon.com返回权威服务器的IP地址；最后，该客户与amazon.com权威服务器之一联系，它为主机名www.amazon.com返回其IP地址

- 根DNS服务器：有400多个根名字服务器遍及世界。这些根名字服务器由13个不同的组织管理，根名字服务器提供TLD服务器的IP地址

- 顶级域DNS服务器：对于每个顶级域(com、org、net、edu和gov)和所有国家的顶级域(uk、fr、ca和jp)都有TLD服务器。TLD服务器提供了权威DNS服务器的IP地址

- 权威DNS服务器：在Internet上具有公共可访问主机的每个组织机构必须提供公共可访问的DNS记录，这些记录将这些主机的名字映射为IP地址，一个组织机构的权威DNS服务器收藏了这些DNS记录。

根、TLD和权威DNS服务器都处在该DNS服务器的层次结构中。还有另一类重要的DNS服务器，称为**本地DNS服务器**。严格来说一个本地DNS服务器并不属于该服务器的层次结构，但它对DNS层次结构使至关重要的。每个ISP都有一台本地DNS服务器(也叫默认名字服务器)。当主机与某个ISP连接时，该ISP提供一台主机的IP地址，该主机具有一台或多台其本地DNS服务器的IP地址。主机的本地DNS服务器通常“邻近”本主机

一般而言，TLD服务器并不总是知道用于主机的权威DNS服务器的IP地址，TLD服务器只是知道中间的某个DNS服务器，该中间DNS服务器以此才能知道用于该主机的权威DNS服务器

#### DNS缓存

为了改善时延性能并减少在Internet上到处传输的DNS报文数量，DNS广泛使用了缓存技术。DNS缓存的原理是：在一个请求链中，当某DNS服务器接收到一个DNS回答时，它能将映射缓存在本地存储器中。如果在DNS服务器中缓存了一个主机名/IP地址对，另一个对相同主机名的查询到达该DNS服务器时，该DNS服务器就能够提供所要求的IP地址，即使它不是该主机名的权威服务器。由于主机和主机名与IP地址间的映射并不是永久的，DNS服务器在一段时间后将丢弃缓存的信息

本地DNS服务器也能够缓存TLD服务器的IP地址，因而允许本地DNS绕过查询链中的根DNS服务器。事实上，因为缓存，除了少数DNS查询以外，根服务器都被绕过了